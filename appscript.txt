// =================================================================
// CONFIGURATION
// =================================================================

// IMPORTANT: This should be the URL of your deployed frontend web app.
// Used for CORS headers to ensure security.
const WEB_APP_URL = 'https://rate.ukmusiciansnetwork.com'; 

// --- Sheet Names (NEW STRUCTURE) ---
const USERS_SHEET_NAME = 'Users';
const VENUES_SHEET_NAME = 'Venues';
const EVENTS_SHEET_NAME = 'Events';
const RATINGS_SHEET_NAME = 'Ratings';
const PERFORMER_STATS_SHEET_NAME = 'PerformerStats';
const RATER_STATS_SHEET_NAME = 'RaterStats';
const DATA_VALIDATION_SHEET_NAME = 'DataValidation';
const BOOKINGS_SHEET_NAME = 'Bookings';


// --- Token Expiration (in minutes) ---
const TOKEN_EXPIRATION_MINUTES = 15;
const EMAIL_CHANGE_TOKEN_EXPIRATION_MINUTES = 60;


// --- Gameplay Mechanics ---
const DAILY_XP_COOLDOWN_PERCENTAGE = 0.05; // 5% daily cooldown

// --- Scout Points (SP) for Raters ---
const SP_PER_RATING = 5;
const SP_FOR_TAGS = 10;
const SP_FOR_SHORT_COMMENT = 5;
const SP_FOR_DETAILED_COMMENT = 20;
const MIN_SHORT_COMMENT_LENGTH = 5;
const MIN_DETAILED_COMMENT_LENGTH = 50;


// --- Gemini API Configuration ---
const API_KEY = PropertiesService.getScriptProperties().getProperty('API_KEY');


// =================================================================
// MAIN ROUTER & ENDPOINTS (doGet, doPost)
// =================================================================

/**
 * Handles GET requests. Acts as a router.
 * - Default: Returns a JSON status for app diagnostics.
 * - With ?action=manifest: Returns an XML manifest of the spreadsheet structure.
 */
function doGet(e) {
  const action = e && e.parameter && e.parameter.action;
  
  if (action === 'verifyEmailChange') {
    const token = e.parameter.token;
    return handleVerifyEmailChange(token);
  }

  // Test function for diagnostics
  if (action === 'test') {
    return testHttpHeader();
  }

  if (action === 'manifest') {
    const targetId = e.parameter.id ? e.parameter.id : SpreadsheetApp.getActive().getId();
    const ss = SpreadsheetApp.openById(targetId);
    const { xml } = buildManifestXML_(ss);
    return ContentService.createTextOutput(xml).setMimeType(ContentService.MimeType.XML);
  }

  // Default behavior for the app's connection test
  return createSuccessResponse({ message: "Deployment is active." });
}

/**
 * Handles POST requests, which is the main entry point for the app.
 */
function doPost(e) {
  try {
    const payload = JSON.parse(e.postData.contents);
    switch(payload.action) {
      // Existing Actions
      case 'getPerformers': return handleGetPerformers(payload.venueName);
      case 'submitRatings': return handleSubmitRatings(payload);
      case 'requestLogin': return handleRequestLogin(payload);
      case 'verifyToken': return handleVerifyToken(payload.token);
      case 'getVenuesForToday': return handleGetVenuesForToday();
      case 'getTodaysRatings': return handleGetTodaysRatings(payload);
      case 'getLeaderboardData': return handleGetLeaderboardData(payload.venueName, 'today');
      case 'getAllTimeLeaderboardData': return handleGetLeaderboardData(payload.venueName, 'all_time');
      case 'getFeedbackTags': return handleGetFeedbackTags();
      case 'getTodaysFeedbackSummary': return handleGetFeedbackSummary(payload, 'today');
      case 'getAllTimeFeedbackSummary': return handleGetFeedbackSummary(payload, 'all_time');
      case 'getRaterStats': return handleGetRaterStats(payload.raterEmail);
      case 'getScoutLevels': return handleGetScoutLevels();
      case 'registerPerformer': return handleRegisterPerformer(payload);
      case 'updatePerformer': return handleUpdatePerformer(payload);
      case 'requestEmailChange': return handleRequestEmailChange(payload);
      case 'loginOrCreateRater': return handleLoginOrCreateRater(payload);
      case 'loginByEmail': return handleLoginByEmail(payload.email);
      case 'requestPerformerLoginLink': return handleRequestPerformerLoginLink(payload.email);
      case 'debugDateParsing': return handleDebugDateParsing();
      // New Booking Actions
      case 'getUpcomingEvents': return handleGetUpcomingEvents();
      case 'getPerformerBookings': return handleGetPerformerBookings(payload.userId);
      case 'getEventDetails': return handleGetEventDetails(payload.eventId);
      case 'bookSlot': return handleBookSlot(payload.eventId, payload.userId, payload.slotNumber);
      case 'cancelBooking': return handleCancelBooking(payload.bookingId, payload.userId);
      default: return createErrorResponse(`Unknown action: ${payload.action}`, 400);
    }
  } catch (err) {
    Logger.log(`doPost Error: ${err.message}\nStack: ${err.stack}`);
    return createErrorResponse(`Server Error: ${err.message}`, 500);
  }
}

// =================================================================
// CUSTOM MENU & MANIFEST FUNCTIONS (from Menu Functions.gs)
// =================================================================

/**
 * Adds a custom 'Manifest' menu to the Google Sheet UI when it's opened.
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Manifest')
    .addItem('Generate XML Manifest (save to Drive)', 'generateSheetManifestXML')
    .addItem('Preview XML in Log', 'previewSheetManifestXML')
    .addToUi();
}

/**
 * Generates the XML manifest and saves it as a file in Google Drive.
 */
function generateSheetManifestXML() {
  const { xml, filename } = buildManifestXML_(SpreadsheetApp.getActive());
  const blob = Utilities.newBlob(xml, 'application/xml', filename);
  const file = DriveApp.createFile(blob);
  SpreadsheetApp.getActive().toast('XML manifest created: ' + file.getUrl(), 'Done', 10);
  Logger.log('Manifest URL: %s', file.getUrl());
}

/**
 * Generates the XML manifest and logs it to the Apps Script logger for previewing.
 */
function previewSheetManifestXML() {
  const { xml } = buildManifestXML_(SpreadsheetApp.getActive());
  Logger.log(xml);
}

/**
 * Core logic to build the XML manifest string from a spreadsheet object.
 * @param {Spreadsheet} ss The spreadsheet to manifest.
 * @returns {{xml: string, filename: string}} The generated XML and a suggested filename.
 */
function buildManifestXML_(ss) {
  const esc = (s) => String(s ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');

  const sheets = ss.getSheets();
  const parts = [];
  parts.push('<?xml version="1.0" encoding="UTF-8"?>');
  parts.push(`<spreadsheet name="${esc(ss.getName())}" id="${esc(ss.getId())}">`);

  sheets.forEach((sh, idx) => {
    const lastCol = sh.getLastColumn();
    const headers = lastCol > 0
      ? sh.getRange(1, 1, 1, lastCol).getDisplayValues()[0]
      : [];
    const headerXml = headers
      .map(h => `      <h>${esc(h)}</h>`)
      .join('\n');

    parts.push(
      `  <sheet name="${esc(sh.getName())}" index="${idx}" gid="${sh.getSheetId()}">`,
      '    <headers>',
      headerXml || '      <!-- (no headers found) -->',
      '    </headers>',
      '  </sheet>'
    );
  });

  parts.push('</spreadsheet>');

  const xml = parts.join('\n');
  const filename = `${ss.getName()}_manifest.xml`;
  return { xml, filename };
}


// =================================================================
// TIME-DRIVEN TRIGGERS
// =================================================================

/**
 * Snapshots key stats for all performers. Should be run daily.
 */
function snapshotDailyStats() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
  if (!statsSheet || statsSheet.getLastRow() < 2) {
    Logger.log("snapshotDailyStats: PerformerStats sheet not found or empty. Skipping.");
    return;
  }

  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const range = statsSheet.getRange(2, 1, statsSheet.getLastRow() - 1, statsSheet.getLastColumn());
    const values = range.getValues();
    
    const headers = statsSheet.getRange(1, 1, 1, statsSheet.getLastColumn()).getValues()[0];
    const headerMap = getHeaderMap(headers);
    
    const currentXPIndex = headerMap['currentxp'];
    const prevDayXPIndex = headerMap['previousdayxp'];
    const totalRatingsIndex = headerMap['totalratingsreceived'];
    const prevTotalRatingsIndex = headerMap['previoustotalratings'];
    const sumRatingsIndex = headerMap['sumofallratings'];
    const prevSumRatingsIndex = headerMap['previoussumofallratings'];

    if ([currentXPIndex, prevDayXPIndex, totalRatingsIndex, prevTotalRatingsIndex, sumRatingsIndex, prevSumRatingsIndex].includes(undefined)) {
      throw new Error("snapshotDailyStats: Could not find all required headers in PerformerStats.");
    }

    const newValues = values.map(row => {
      const currentXP = Number(row[currentXPIndex]) || 0;
      
      // Apply cooldown to current XP
      row[currentXPIndex] = Math.floor(currentXP * (1 - DAILY_XP_COOLDOWN_PERCENTAGE));
      
      // Snapshot pre-cooldown stats
      row[prevDayXPIndex] = currentXP;
      row[prevTotalRatingsIndex] = row[totalRatingsIndex];
      row[prevSumRatingsIndex] = row[sumRatingsIndex];
      
      return row;
    });

    range.setValues(newValues);
    Logger.log(`snapshotDailyStats: Successfully updated stats for ${newValues.length} performers.`);

  } catch (e) {
    Logger.log(`snapshotDailyStats: An error occurred: ${e.message}`);
  } finally {
    lock.releaseLock();
  }
}

/**
 * Snapshots weekly XP for all performers. Should be run weekly.
 */
function snapshotWeeklyXP() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
  if (!statsSheet || statsSheet.getLastRow() < 2) return;

  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const range = statsSheet.getRange(2, 1, statsSheet.getLastRow() - 1, statsSheet.getLastColumn());
    const values = range.getValues();
    
    const headers = statsSheet.getRange(1, 1, 1, statsSheet.getLastColumn()).getValues()[0];
    const headerMap = getHeaderMap(headers);
    const currentXPIndex = headerMap['currentxp'];
    const prevWeekXPIndex = headerMap['previousweekxp'];
    
    if (currentXPIndex === undefined || prevWeekXPIndex === undefined) {
      throw new Error("snapshotWeeklyXP: Could not find 'CurrentXP' or 'PreviousWeekXP' headers.");
    }

    values.forEach(row => {
      row[prevWeekXPIndex] = row[currentXPIndex];
    });

    range.setValues(values);
    Logger.log(`snapshotWeeklyXP: Successfully updated weekly XP for ${values.length} performers.`);

  } catch (e) {
    Logger.log(`snapshotWeeklyXP: An error occurred: ${e.message}`);
  } finally {
    lock.releaseLock();
  }
}


// =================================================================
// UTILITY & RESPONSE FUNCTIONS
// =================================================================

/**
 * Finds or creates a nested folder structure.
 * @param {DriveApp.Folder} root The starting folder (e.g., DriveApp.getRootFolder()).
 * @param {string[]} pathArray An array of folder names representing the path.
 * @returns {DriveApp.Folder} The final folder in the path.
 */
function getOrCreateNestedFolder(root, pathArray) {
    let currentFolder = root;
    for (const folderName of pathArray) {
        const folders = currentFolder.getFoldersByName(folderName);
        if (folders.hasNext()) {
            currentFolder = folders.next();
        } else {
            currentFolder = currentFolder.createFolder(folderName);
        }
    }
    return currentFolder;
}


/**
 * Finds a folder by name within a parent folder, or creates it if it doesn't exist.
 * @param {DriveApp.Folder} parentFolder The folder to search within.
 * @param {string} folderName The name of the folder to find or create.
 * @returns {DriveApp.Folder} The found or newly created folder.
 */
function findOrCreateFolder(parentFolder, folderName) {
    const folders = parentFolder.getFoldersByName(folderName);
    if (folders.hasNext()) {
        return folders.next();
    } else {
        return parentFolder.createFolder(folderName);
    }
}


function getHeaderMap(headers) {
  if (!headers || !Array.isArray(headers)) return {};
  return headers.reduce((map, header, index) => {
    if (typeof header === 'string' && header.trim() !== '') {
      map[header.toLowerCase().replace(/[^a-z0-9]/g, '')] = index;
    }
    return map;
  }, {});
}

function getValueByHeader(row, headerMap, targetHeader) {
  const normalizedTarget = targetHeader.toLowerCase().replace(/[^a-z0-9]/g, '');
  const index = headerMap[normalizedTarget];
  return index !== undefined ? row[index] : undefined;
}

function getSpreadsheetTimeZone() {
    return SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone() || "Europe/London";
}

function getFormattedDateTime(date) {
    return Utilities.formatDate(date, getSpreadsheetTimeZone(), 'yyyy-MM-dd HH:mm:ss');
}

function getTodaysDateString() {
    return Utilities.formatDate(new Date(), getSpreadsheetTimeZone(), 'yyyy-MM-dd');
}

function formatSheetTime(timeValue, timezone) {
  if (timeValue instanceof Date) {
    return Utilities.formatDate(timeValue, timezone, "HH:mm");
  }
  // Handles cases where time might be a string already
  if (typeof timeValue === 'string') {
      try {
          // Attempt to parse it as a date to handle various formats
          const parsedDate = new Date(timeValue);
          if (!isNaN(parsedDate)) {
             return Utilities.formatDate(parsedDate, timezone, "HH:mm");
          }
      } catch(e) { /* ignore parse error and return original */ }
  }
  return timeValue;
}

function normalizeDate(dateValue) {
    const timezone = getSpreadsheetTimeZone();
    try {
        if (dateValue instanceof Date && !isNaN(dateValue)) {
            return Utilities.formatDate(dateValue, timezone, 'yyyy-MM-dd');
        }
        if (typeof dateValue === 'string' && dateValue.trim()) {
            // Handle ISO 8601 format like "2024-07-29T23:00:00.000Z"
            if (dateValue.includes('T') && dateValue.endsWith('Z')) {
                return Utilities.formatDate(new Date(dateValue), timezone, 'yyyy-MM-dd');
            }
            // Handle simple date format like "2024-07-30"
            const parsedDate = new Date(dateValue);
            if (!isNaN(parsedDate)) {
                 return Utilities.formatDate(parsedDate, timezone, "yyyy-MM-dd");
            }
        }
        if (typeof dateValue === 'number' && dateValue > 0) {
            // Handle Google Sheets serial number dates
            const millis = (dateValue - 25569) * 86400000;
            const dateInUTC = new Date(millis);
            return Utilities.formatDate(dateInUTC, timezone, "yyyy-MM-dd");
        }
    } catch (e) {
        Logger.log(`Could not normalize date value: '${dateValue}' (type: ${typeof dateValue}). Error: ${e.message}`);
    }
    return null;
}

/**
 * Creates a standard success response.
 * Apps Script automatically handles necessary CORS headers for public web apps on simple requests.
 * @param {object} data The data payload to send.
 * @returns {ContentService.TextOutput}
 */
function createSuccessResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify({ status: 'success', ...data }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Creates a standard error response.
 * @param {string} message The error message.
 * @param {number} [statusCode=500] The HTTP status code (Note: This is informational; Apps Script doesn't allow setting the code here).
 * @returns {ContentService.TextOutput}
 */
function createErrorResponse(message, statusCode = 500) {
  return ContentService
    .createTextOutput(JSON.stringify({ status: 'error', message }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * A minimal test function to diagnose issues with creating responses.
 * @returns {ContentService.TextOutput}
 */
function testHttpHeader() {
  try {
    return ContentService
      .createTextOutput(JSON.stringify({ testStatus: "success" }))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (e) {
    Logger.log('FATAL ERROR in testHttpHeader: ' + e.message);
    return ContentService.createTextOutput('TEST FAILED with error: ' + e.message);
  }
}


// =================================================================
// HANDLER FUNCTIONS
// =================================================================

function handleRegisterPerformer(payload) {
    const lock = LockService.getScriptLock();
    lock.waitLock(30000); 

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
        if (!usersSheet || !statsSheet) throw new Error("Required sheets for registration not found.");

        const headersRaw = usersSheet.getRange(1, 1, 1, usersSheet.getLastColumn()).getValues()[0];
        if (!headersRaw || headersRaw.length === 0) throw new Error("Users sheet is missing headers.");
        const headerMap = getHeaderMap(headersRaw);

        // Check for essential headers to ensure the sheet is structured correctly
        const requiredHeaders = ['userid', 'email', 'firstname', 'lastname', 'performingname', 'registrationdateperformer', 'countrycode'];
        for (const h of requiredHeaders) {
            if (headerMap[h] === undefined) {
                throw new Error(`Critical header "${h}" is missing from the Users sheet.`);
            }
        }

        const newUserID = Utilities.getUuid();
        let imageUrl = '';

        if (payload.imageBase64) {
            if (!payload.imageMimeType || !payload.imageMimeType.startsWith('image/')) {
                throw new Error("Invalid file type. Only images are allowed.");
            }
            
            // --- New Scalable & Nested Folder Structure ---
            const FOLDER_PATH = ['Businesses', 'UK Pub Partner'];
            const targetRootFolder = getOrCreateNestedFolder(DriveApp.getRootFolder(), FOLDER_PATH);
            const performerAssetsFolder = findOrCreateFolder(targetRootFolder, 'PerformerAssets');

            const safePerformerNameForFolder = (payload.performingName || 'performer').replace(/[^a-zA-Z0-9_.-]/g, '_');
            const performerFolderName = `${safePerformerNameForFolder} - ${newUserID}`;
            const performerFolder = findOrCreateFolder(performerAssetsFolder, performerFolderName);
            
            const publicImagesFolder = findOrCreateFolder(performerFolder, 'Public Images');
            findOrCreateFolder(performerFolder, 'Private Documents'); // Create this for future use
            
            // Set permissions for the public folder
            publicImagesFolder.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
            
            // --- Image Upload Logic ---
            const decodedImage = Utilities.base64Decode(payload.imageBase64);
            const blob = Utilities.newBlob(decodedImage, payload.imageMimeType, payload.imageFileName);
            
            const safePerformerName = (payload.performingName || 'performer_image').replace(/[^a-zA-Z0-9_.-]/g, '_');
            const fileExtension = payload.imageFileName.split('.').pop() || 'jpg';
            const newFileName = `${safePerformerName}_thumbnail.${fileExtension}`;

            const file = publicImagesFolder.createFile(blob).setName(newFileName);
            file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); // Explicitly set file permission
            
            imageUrl = `https://lh3.googleusercontent.com/d/${file.getId()}`;
        }
        
        const today = new Date();
        
        const newRow = new Array(headersRaw.length).fill('');
        newRow[headerMap['userid']] = newUserID;
        newRow[headerMap['email']] = payload.email.trim().toLowerCase();
        newRow[headerMap['firstname']] = payload.firstName;
        newRow[headerMap['lastname']] = payload.lastName;
        newRow[headerMap['countrycode']] = payload.countryCode || '';
        newRow[headerMap['mobilenumber']] = payload.mobile || '';
        newRow[headerMap['creationdate']] = getFormattedDateTime(today);
        newRow[headerMap['performingname']] = payload.performingName;
        newRow[headerMap['bio']] = payload.bio || '';
        newRow[headerMap['sociallink']] = payload.socialLink || '';
        newRow[headerMap['streaminglink']] = payload.streamingLink || '';
        newRow[headerMap['imageurl']] = imageUrl;
        newRow[headerMap['registrationdateperformer']] = getFormattedDateTime(today);
        
        usersSheet.appendRow(newRow);
        
        const statsHeadersRaw = statsSheet.getRange(1, 1, 1, statsSheet.getLastColumn()).getValues()[0];
        const statsHeaderMap = getHeaderMap(statsHeadersRaw);
        const newStatsRow = new Array(statsHeadersRaw.length).fill(0);
        newStatsRow[statsHeaderMap['userid']] = newUserID;
        newStatsRow[statsHeaderMap['performername']] = payload.performingName;
        newStatsRow[statsHeaderMap['lastupdated']] = getFormattedDateTime(today);

        statsSheet.appendRow(newStatsRow);
        
        return createSuccessResponse({ message: 'Performer registered successfully.', userId: newUserID });

    } catch(err) {
        Logger.log(`Registration Error: ${err.message}\nStack: ${err.stack}`);
        return createErrorResponse(err.message);
    } finally {
        lock.releaseLock();
    }
}


function handleUpdatePerformer(payload) {
    const { userId } = payload;
    if (!userId) return createErrorResponse("User ID is required for update.", 400);

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        if (!usersSheet) throw new Error("Users sheet not found.");
        
        const data = usersSheet.getDataRange().getValues();
        const headersRaw = data.shift();
        if (!headersRaw) throw new Error("Users sheet is empty or has no headers.");
        const headerMap = getHeaderMap(headersRaw);

        const userIdIndex = headerMap['userid'];
        if (userIdIndex === undefined) throw new Error("UserID column not found in Users sheet.");

        const rowIndex = data.findIndex(row => row[userIdIndex] === userId);
        if (rowIndex === -1) throw new Error("Performer not found.");
        
        const sheetRowIndex = rowIndex + 2; // +1 for 1-based index, +1 for header row
        
        // Map of payload keys to header keys for updating. Exclude email as it has a separate flow.
        const updateMap = {
            firstName: 'firstname',
            lastName: 'lastname',
            performingName: 'performingname',
            countryCode: 'countrycode',
            mobile: 'mobilenumber',
            bio: 'bio',
            socialLink: 'sociallink',
            streamingLink: 'streaminglink'
        };

        for (const [payloadKey, headerKey] of Object.entries(updateMap)) {
            if (payload[payloadKey] !== undefined) {
                const colIndex = headerMap[headerKey];
                if (colIndex !== undefined) {
                    usersSheet.getRange(sheetRowIndex, colIndex + 1).setValue(payload[payloadKey]);
                }
            }
        }
        
        // Also update performer name in stats sheet if it changes
        if (payload.performingName && headerMap['performingname'] !== undefined) {
            const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
            const statsData = statsSheet.getDataRange().getValues();
            const statsHeaderRaw = statsData.shift();
            const statsHeaderMap = getHeaderMap(statsHeaderRaw);
            const statsUserIdIndex = statsHeaderMap['userid'];
            const statsNameIndex = statsHeaderMap['performername'];
            if(statsUserIdIndex !== undefined && statsNameIndex !== undefined) {
                 const statsRowIndex = statsData.findIndex(row => row[statsUserIdIndex] === userId);
                 if(statsRowIndex !== -1) {
                     statsSheet.getRange(statsRowIndex + 2, statsNameIndex + 1).setValue(payload.performingName);
                 }
            }
        }
        
        return createSuccessResponse({ message: 'Profile updated successfully.' });

    } catch (err) {
        Logger.log(`handleUpdatePerformer Error: ${err.message}\nStack: ${err.stack}`);
        return createErrorResponse(err.message);
    } finally {
        lock.releaseLock();
    }
}


function handleLoginOrCreateRater(payload) {
  const email = (payload.email || '').trim().toLowerCase();
  const { firstName, lastName } = payload;

  if (!email || !firstName || !lastName) {
    return createErrorResponse("Missing required fields for rater login/creation.", 400);
  }

  const lock = LockService.getUserLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) throw new Error("Users sheet not found.");

    const data = usersSheet.getDataRange().getValues();
    const headersRaw = data.shift();
    if (!headersRaw) throw new Error("Users sheet is empty or has no headers.");
    const headers = getHeaderMap(headersRaw);
    
    const emailIndex = headers['email'];
    if (emailIndex === undefined) throw new Error("Email column not found in Users sheet.");

    const userRow = data.find(row => row[emailIndex] && row[emailIndex].toLowerCase() === email);

    if (userRow) {
      // User already exists, nothing to do.
      return createSuccessResponse({ message: 'Rater already exists.' });
    } else {
      // User does not exist, create them.
      const userId = Utilities.getUuid();
      
      const newRow = new Array(headersRaw.length).fill('');
      newRow[headers['userid']] = userId;
      newRow[headers['email']] = email;
      newRow[headers['firstname']] = firstName;
      newRow[headers['lastname']] = lastName;
      newRow[headers['creationdate']] = getFormattedDateTime(new Date());
      
      usersSheet.appendRow(newRow);
      return createSuccessResponse({ message: 'Rater created successfully.' });
    }
  } catch (err) {
    Logger.log(`handleLoginOrCreateRater Error: ${err.message}\nStack: ${err.stack}`);
    return createErrorResponse(err.message);
  } finally {
    lock.releaseLock();
  }
}

function handleLoginByEmail(email) {
    if (!email) return createErrorResponse("Email is required.", 400);
    
    const userEmail = email.trim().toLowerCase();
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) throw new Error("Users sheet not found.");

    const data = usersSheet.getDataRange().getValues();
    const headersRaw = data.shift();
    if (!headersRaw) throw new Error("Users sheet is empty or has no headers.");
    const headerMap = getHeaderMap(headersRaw);

    const emailIndex = headerMap['email'];
    if (emailIndex === undefined) throw new Error("Email column not found in Users sheet.");
    
    const userRow = data.find(row => row[emailIndex] && row[emailIndex].toLowerCase() === userEmail);
    if (!userRow) throw new Error("No user found with that email address. Please register first.");
    
    const performingName = getValueByHeader(userRow, headerMap, 'performingname');
    const userType = performingName ? 'performer' : 'audience';
    
    const userData = {
        id: getValueByHeader(userRow, headerMap, 'userid'),
        firstName: getValueByHeader(userRow, headerMap, 'firstname'),
        lastName: getValueByHeader(userRow, headerMap, 'lastname'),
        performingName: performingName,
        email: getValueByHeader(userRow, headerMap, 'email'),
        countryCode: getValueByHeader(userRow, headerMap, 'countrycode'),
        mobile: getValueByHeader(userRow, headerMap, 'mobilenumber'),
        bio: getValueByHeader(userRow, headerMap, 'bio'),
        socialLink: getValueByHeader(userRow, headerMap, 'sociallink'),
        streamingLink: getValueByHeader(userRow, headerMap, 'streaminglink'),
        image: getValueByHeader(userRow, headerMap, 'imageurl')
    };
    
    return createSuccessResponse({ user: userData, userType: userType });
}


function handleGetPerformers(venueName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
  const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
  const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);

  if (!venuesSheet || !eventsSheet || !usersSheet) {
    return createErrorResponse("Data model sheets not found (Venues, Events, or Users).");
  }

  // 1. Find VenueID from venueName
  const venuesData = venuesSheet.getDataRange().getValues();
  const venuesHeadersRaw = venuesData.shift();
  if (!venuesHeadersRaw) return createSuccessResponse({ performers: [] }); // Empty venues sheet
  const venuesHeaders = getHeaderMap(venuesHeadersRaw);
  const venueRow = venuesData.find(row => getValueByHeader(row, venuesHeaders, 'VenueName') === venueName);
  if (!venueRow) return createSuccessResponse({ performers: [] });
  const venueId = getValueByHeader(venueRow, venuesHeaders, 'VenueID');

  // 2. Find today's events for that VenueID
  const todaysDate = getTodaysDateString();
  const eventsData = eventsSheet.getDataRange().getValues();
  const eventsHeadersRaw = eventsData.shift();
  if (!eventsHeadersRaw) return createSuccessResponse({ performers: [] }); // Empty events sheet
  const eventsHeaders = getHeaderMap(eventsHeadersRaw);
  
  const todaysEvents = eventsData.filter(row => {
    return normalizeDate(getValueByHeader(row, eventsHeaders, 'EventDate')) === todaysDate &&
           getValueByHeader(row, eventsHeaders, 'VenueID') === venueId;
  });
  
  // 3. Get performer details from Users sheet
  const usersData = usersSheet.getDataRange().getValues();
  const usersHeadersRaw = usersData.shift();
  if (!usersHeadersRaw) return createSuccessResponse({ performers: [] }); // Empty users sheet
  const usersHeaders = getHeaderMap(usersHeadersRaw);
  const usersMap = new Map(usersData.map(row => [getValueByHeader(row, usersHeaders, 'UserID'), row]));
  
  // 4. Combine data
  const performers = todaysEvents.map(eventRow => {
    const userId = getValueByHeader(eventRow, eventsHeaders, 'UserID');
    const userRow = usersMap.get(userId);
    if (!userRow) return null;
    
    return {
      id: userId,
      name: getValueByHeader(userRow, usersHeaders, 'PerformingName'),
      bio: getValueByHeader(userRow, usersHeaders, 'Bio'),
      socialLink: getValueByHeader(userRow, usersHeaders, 'SocialLink'),
      streamingLink: getValueByHeader(userRow, usersHeaders, 'StreamingLink'),
      slot: Number(getValueByHeader(eventRow, eventsHeaders, 'SlotNumber')) || undefined,
      image: getValueByHeader(userRow, usersHeaders, 'ImageURL')
    };
  }).filter(Boolean); // Filter out any nulls if a user wasn't found
  
  return createSuccessResponse({ performers });
}

function handleRequestLogin(payload) {
  const email = (payload.email || '').trim().toLowerCase();
  const { venueName, firstName, lastName } = payload;
  if (!email || !venueName || !firstName || !lastName) {
    return createErrorResponse("Missing required fields.", 400);
  }

  const lock = LockService.getUserLock();
  lock.waitLock(30000);

  try {
    const usersSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(USERS_SHEET_NAME);
    const data = usersSheet.getDataRange().getValues();
    const headersRaw = data.shift();
    if (!headersRaw) throw new Error("Users sheet is empty or has no headers.");
    const headers = getHeaderMap(headersRaw);
    
    const emailIndex = headers['email'];
    const userRow = data.find(row => row[emailIndex] && row[emailIndex].toLowerCase() === email);
    let userId;

    if (userRow) {
      userId = getValueByHeader(userRow, headers, 'UserID');
    } else {
      userId = Utilities.getUuid();
      usersSheet.appendRow([userId, email, firstName, lastName, '', '', getFormattedDateTime(new Date())]);
    }
    
    const token = "T" + Utilities.getUuid().replace(/-/g, "");
    const expiry = new Date().getTime() + TOKEN_EXPIRATION_MINUTES * 60 * 1000;
    PropertiesService.getScriptProperties().setProperty(token, JSON.stringify({ userId, email, venueName, firstName, lastName, expiry, type: 'rater' }));

    const loginUrl = `${WEB_APP_URL}?token=${token}`;
    MailApp.sendEmail({
      to: email,
      subject: `Your Secure Login Link for ${venueName}`,
      htmlBody: `Hello ${firstName},<br><br>Click the link below to securely log in to rate performers at ${venueName}.<br><br><a href="${loginUrl}" style="padding: 10px 20px; background-color: #6d28d9; color: white; text-decoration: none; border-radius: 5px;">Log In Now</a><br><br>This link expires in ${TOKEN_EXPIRATION_MINUTES} minutes.`,
      name: "UKMN Rating App"
    });

    return createSuccessResponse({ message: 'Login link sent.' });

  } finally {
    lock.releaseLock();
  }
}

function handleRequestPerformerLoginLink(email) {
    if (!email) return createErrorResponse("Email is required.", 400);
     // This is a placeholder for the full magic link implementation
     // It would find the performer, create a token, store it, and email the link.
     // For now, it just confirms the action would have been taken.
    return createSuccessResponse({ message: `A login link would be sent to ${email}.` });
}

function handleVerifyToken(token) {
  if (!token) return createErrorResponse("No token provided.", 400);

  const scriptProperties = PropertiesService.getScriptProperties();
  const tokenDataString = scriptProperties.getProperty(token);
  if (!tokenDataString) return createErrorResponse("Invalid or expired login link.", 401);

  scriptProperties.deleteProperty(token); 
  const tokenData = JSON.parse(tokenDataString);

  if (new Date().getTime() > tokenData.expiry) {
    return createErrorResponse("Login link has expired.", 401);
  }
  
  // Logic could be added here to handle different token 'types' (e.g., 'rater' vs 'performer')
  // For now, it only handles rater logins.
  
  return createSuccessResponse({
    email: tokenData.email,
    venue: tokenData.venueName,
    firstName: tokenData.firstName,
    lastName: tokenData.lastName
  });
}

function handleGetVenuesForToday() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
    const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
    if (!eventsSheet || !venuesSheet) throw new Error("Missing Events or Venues sheet.");

    // 1. Cache all venues
    const venuesData = venuesSheet.getDataRange().getValues();
    const venuesHeaderRaw = venuesData.shift(); // remove headers
    if (!venuesHeaderRaw) return createSuccessResponse({ venues: [] });
    const venuesHeaders = getHeaderMap(venuesHeaderRaw);
    if (venuesData.length === 0) return createSuccessResponse({ venues: [] });
    const venuesMap = new Map(venuesData.map(row => [getValueByHeader(row, venuesHeaders, 'venueid'), getValueByHeader(row, venuesHeaders, 'venuename')]));

    // 2. Find today's events
    const todaysDate = getTodaysDateString();
    const eventsData = eventsSheet.getDataRange().getValues();
    const eventsHeadersRaw = eventsData.shift();
    if (!eventsHeadersRaw) return createSuccessResponse({ venues: [] });
    const eventsHeaders = getHeaderMap(eventsHeadersRaw);
    
    const todaysVenueIds = new Set();
    eventsData.forEach(row => {
        if (normalizeDate(getValueByHeader(row, eventsHeaders, 'EventDate')) === todaysDate) {
            todaysVenueIds.add(getValueByHeader(row, eventsHeaders, 'VenueID'));
        }
    });

    // 3. Map IDs to Names
    const venues = Array.from(todaysVenueIds).map(id => venuesMap.get(id)).filter(Boolean);
    
    return createSuccessResponse({ venues });
}

function handleSubmitRatings(payload) {
    const { ratings, raterEmail, venueName, firstName, lastName, latitude, longitude } = payload;
    if (!ratings || !raterEmail || !venueName) {
        return createErrorResponse("Missing required rating data.", 400);
    }
    
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        const usersData = usersSheet.getDataRange().getValues();
        const usersHeadersRaw = usersData.shift();
        if (!usersHeadersRaw) throw new Error("Users sheet is empty or missing headers.");
        const usersHeaders = getHeaderMap(usersHeadersRaw);
        const normalizedRaterEmail = raterEmail.trim().toLowerCase();
        const raterRow = usersData.find(row => getValueByHeader(row, usersHeaders, 'email').toLowerCase() === normalizedRaterEmail);
        if (!raterRow) throw new Error("Rater not found.");
        const raterId = getValueByHeader(raterRow, usersHeaders, 'userid');

        const timestamp = new Date();
        let totalPointsEarned = 0;
        
        const ratingsToAdd = ratings.map(rating => {
            let points = 0;
            if (rating.rating > 0) points += SP_PER_RATING;
            if (rating.feedbackTags?.length) points += SP_FOR_TAGS;
            if (rating.comment?.length >= MIN_DETAILED_COMMENT_LENGTH) {
                points += SP_FOR_DETAILED_COMMENT;
            } else if (rating.comment?.length >= MIN_SHORT_COMMENT_LENGTH) {
                points += SP_FOR_SHORT_COMMENT;
            }
            totalPointsEarned += points;

            return [
                "rating-" + Utilities.getUuid(), getFormattedDateTime(timestamp), raterId, rating.id, rating.rating,
                rating.comment || '', (rating.feedbackTags || []).join(', '),
                venueName, latitude, longitude
            ];
        });

        if (ratingsToAdd.length > 0) {
            const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
            ratingsSheet.getRange(ratingsSheet.getLastRow() + 1, 1, ratingsToAdd.length, ratingsToAdd[0].length).setValues(ratingsToAdd);
        }

        // --- Update RaterStats ---
        const raterStatsSheet = ss.getSheetByName(RATER_STATS_SHEET_NAME);
        const raterStatsData = raterStatsSheet.getDataRange().getValues();
        const raterStatsHeadersRaw = raterStatsData.shift();
        if (!raterStatsHeadersRaw) throw new Error("RaterStats sheet is empty or missing headers.");
        const raterStatsHeaders = getHeaderMap(raterStatsHeadersRaw);
        const raterStatsRowIndex = raterStatsData.findIndex(row => getValueByHeader(row, raterStatsHeaders, 'userid') === raterId);
        
        const commentsInSubmission = ratings.filter(r => r.comment?.trim()).length;
        if (raterStatsRowIndex > -1) {
            const rowIndex = raterStatsRowIndex + 2;
            const row = raterStatsData[raterStatsRowIndex];
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['totalsp'] + 1).setValue((Number(getValueByHeader(row, raterStatsHeaders, 'totalsp')) || 0) + totalPointsEarned);
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['ratingssubmitted'] + 1).setValue((Number(getValueByHeader(row, raterStatsHeaders, 'ratingssubmitted')) || 0) + ratings.length);
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['commentswritten'] + 1).setValue((Number(getValueByHeader(row, raterStatsHeaders, 'commentswritten')) || 0) + commentsInSubmission);
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['lastupdated'] + 1).setValue(getFormattedDateTime(timestamp));
        } else {
            raterStatsSheet.appendRow([raterId, normalizedRaterEmail, totalPointsEarned, ratings.length, commentsInSubmission, getFormattedDateTime(timestamp)]);
        }

        // --- Batch update PerformerStats ---
        const performerStatsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
        const allStatsData = performerStatsSheet.getDataRange().getValues();
        const statsHeadersRaw = allStatsData.shift();
        if (!statsHeadersRaw) throw new Error("PerformerStats sheet is empty or missing headers.");
        const statsHeaders = getHeaderMap(statsHeadersRaw);
        const statsMap = new Map(allStatsData.map(row => [getValueByHeader(row, statsHeaders, 'userid'), row]));
        
        const allRatingsData = ss.getSheetByName(RATINGS_SHEET_NAME).getDataRange().getValues();
        const ratingsHeadersRaw = allRatingsData.shift();
        if (!ratingsHeadersRaw) throw new Error("Ratings sheet is empty or missing headers.");
        const ratingsHeaders = getHeaderMap(ratingsHeadersRaw);

        const performersToUpdate = new Set(ratings.map(r => r.id));
        performersToUpdate.forEach(performerId => {
            const performerRatings = allRatingsData.filter(r => getValueByHeader(r, ratingsHeaders, 'performeruserid') === performerId);
            const totalRatings = performerRatings.length;
            const sumOfRatings = performerRatings.reduce((sum, r) => sum + (Number(getValueByHeader(r, ratingsHeaders, 'score')) || 0), 0);
            const uniqueRaters = new Set(performerRatings.map(r => getValueByHeader(r, ratingsHeaders, 'rateruserid'))).size;
            const commentsCount = performerRatings.filter(r => getValueByHeader(r, ratingsHeaders, 'comment')?.trim()).length;

            const xp = (totalRatings * SP_PER_RATING) + (commentsCount * SP_FOR_SHORT_COMMENT);
            
            const statsRow = statsMap.get(performerId);
            if (statsRow) {
                statsRow[statsHeaders['totalratingsreceived']] = totalRatings;
                statsRow[statsHeaders['sumofallratings']] = sumOfRatings;
                statsRow[statsHeaders['uniqueratercount']] = uniqueRaters;
                statsRow[statsHeaders['currentxp']] = xp;
                statsRow[statsHeaders['lastupdated']] = getFormattedDateTime(timestamp);
                statsMap.set(performerId, statsRow);
            }
        });

        const updatedStatsValues = Array.from(statsMap.values());
        if (updatedStatsValues.length > 0) {
            performerStatsSheet.getRange(2, 1, updatedStatsValues.length, updatedStatsValues[0].length).setValues(updatedStatsValues);
        }

        return createSuccessResponse({ pointsEarned: totalPointsEarned });

    } catch (err) {
        Logger.log(`handleSubmitRatings Error: ${err.message}\nStack: ${err.stack}`);
        return createErrorResponse(`Submission failed: ${err.message}`);
    } finally {
        lock.releaseLock();
    }
}


function handleGetTodaysRatings(payload) {
    const { raterEmail, venueName } = payload;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
    
    const usersData = usersSheet.getDataRange().getValues();
    const usersHeadersRaw = usersData.shift();
    if (!usersHeadersRaw) return createSuccessResponse({ ratings: {} });
    const usersHeaders = getHeaderMap(usersHeadersRaw);

    const normalizedRaterEmail = (raterEmail || '').trim().toLowerCase();
    const raterRow = usersData.find(row => getValueByHeader(row, usersHeaders, 'email').toLowerCase() === normalizedRaterEmail);
    if (!raterRow) return createSuccessResponse({ ratings: {} });
    const raterId = getValueByHeader(raterRow, usersHeaders, 'userid');

    const todaysDate = getTodaysDateString();
    const allRatings = ratingsSheet.getDataRange().getValues();
    const ratingsHeadersRaw = allRatings.shift();
    if (!ratingsHeadersRaw) return createSuccessResponse({ ratings: {} });
    const ratingsHeaders = getHeaderMap(ratingsHeadersRaw);

    const ratingsMap = {};
    allRatings.forEach(row => {
        if (getValueByHeader(row, ratingsHeaders, 'rateruserid') === raterId &&
            getValueByHeader(row, ratingsHeaders, 'venuename') === venueName &&
            normalizeDate(getValueByHeader(row, ratingsHeaders, 'timestamp')) === todaysDate) {
            ratingsMap[getValueByHeader(row, ratingsHeaders, 'performeruserid')] = getValueByHeader(row, ratingsHeaders, 'score');
        }
    });

    return createSuccessResponse({ ratings: ratingsMap });
}

function handleGetLeaderboardData(venueName, timeFrame) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
    if (!statsSheet) return createErrorResponse("Stats sheet not found.");
    
    const statsData = statsSheet.getDataRange().getValues();
    const statsHeadersRaw = statsData.shift();
    if (!statsHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const statsHeaders = getHeaderMap(statsHeadersRaw);

    if (timeFrame === 'all_time') {
        const leaderboard = statsData.map(row => {
            const totalRatings = Number(getValueByHeader(row, statsHeaders, 'totalratingsreceived')) || 0;
            if (totalRatings === 0) return null;
            const sumRatings = Number(getValueByHeader(row, statsHeaders, 'sumofallratings')) || 0;
            
            const prevTotalRatings = Number(getValueByHeader(row, statsHeaders, 'previoustotalratings')) || 0;
            const prevSumRatings = Number(getValueByHeader(row, statsHeaders, 'previoussumofallratings')) || 0;
            const prevAvg = prevTotalRatings > 0 ? prevSumRatings / prevTotalRatings : 0;
            const currentAvg = sumRatings / totalRatings;

            let ratingTrend = 'STABLE';
            if (currentAvg > prevAvg) ratingTrend = 'UP';
            if (currentAvg < prevAvg) ratingTrend = 'DOWN';

            const currentXP = Number(getValueByHeader(row, statsHeaders, 'currentxp')) || 0;
            const prevWeekXP = Number(getValueByHeader(row, statsHeaders, 'previousweekxp')) || 0;
            let xpTrend = 'STABLE';
            if (currentXP > prevWeekXP) xpTrend = 'UP';
            if (currentXP < prevWeekXP) xpTrend = 'DOWN';
            
            return {
                id: getValueByHeader(row, statsHeaders, 'userid'),
                name: getValueByHeader(row, statsHeaders, 'performername'),
                averageRating: currentAvg,
                ratingCount: totalRatings,
                commentCount: 0, // Note: Comment count not in new stats sheet, default to 0
                xp: currentXP,
                xpTrend: xpTrend,
                ratingTrend: ratingTrend
            };
        }).filter(Boolean);

        leaderboard.sort((a, b) => b.averageRating - a.averageRating || b.ratingCount - a.ratingCount);
        return createSuccessResponse({ leaderboard });
    }

    // --- Logic for 'today' ---
    const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
    const eventsData = eventsSheet.getDataRange().getValues();
    const eventsHeadersRaw = eventsData.shift();
    if (!eventsHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const eventsHeaders = getHeaderMap(eventsHeadersRaw);

    const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
    const venuesData = venuesSheet.getDataRange().getValues();
    const venuesHeadersRaw = venuesData.shift();
    if (!venuesHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const venuesHeaders = getHeaderMap(venuesHeadersRaw);

    const venueRow = venuesData.find(r => getValueByHeader(r, venuesHeaders, 'venuename') === venueName);
    if (!venueRow) return createSuccessResponse({ leaderboard: [] });
    const venueId = getValueByHeader(venueRow, venuesHeaders, 'venueid');

    const todaysDate = getTodaysDateString();
    const performersToday = new Set(eventsData
        .filter(r => normalizeDate(getValueByHeader(r, eventsHeaders, 'eventdate')) === todaysDate && getValueByHeader(r, eventsHeaders, 'venueid') === venueId)
        .map(r => getValueByHeader(r, eventsHeaders, 'userid'))
    );

    const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
    const ratingsData = ratingsSheet.getDataRange().getValues();
    const ratingsHeadersRaw = ratingsData.shift();
    if (!ratingsHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const ratingsHeaders = getHeaderMap(ratingsHeadersRaw);

    const todaysRatings = {}; // { performerId: { ratings: [], comments: 0 } }
    ratingsData.forEach(row => {
        const performerId = getValueByHeader(row, ratingsHeaders, 'performeruserid');
        if (performersToday.has(performerId) && normalizeDate(getValueByHeader(row, ratingsHeaders, 'timestamp')) === todaysDate) {
            if (!todaysRatings[performerId]) {
                todaysRatings[performerId] = { ratings: [], comments: 0 };
            }
            todaysRatings[performerId].ratings.push(Number(getValueByHeader(row, ratingsHeaders, 'score')) || 0);
            if (getValueByHeader(row, ratingsHeaders, 'comment')?.trim()) {
                todaysRatings[performerId].comments++;
            }
        }
    });

    const statsMap = new Map(statsData.map(row => [getValueByHeader(row, statsHeaders, 'userid'), row]));
    
    const leaderboard = Object.keys(todaysRatings).map(performerId => {
        const statsRow = statsMap.get(performerId);
        if (!statsRow) return null;

        const todaysData = todaysRatings[performerId];
        const todaysSum = todaysData.ratings.reduce((a, b) => a + b, 0);
        const todaysAvg = todaysSum / todaysData.ratings.length;

        const totalRatings = Number(getValueByHeader(statsRow, statsHeaders, 'totalratingsreceived')) || 0;
        const sumRatings = Number(getValueByHeader(statsRow, statsHeaders, 'sumofallratings')) || 0;
        const allTimeAvg = totalRatings > 0 ? sumRatings / totalRatings : 0;
        
        let ratingTrend = 'STABLE';
        if (todaysAvg > allTimeAvg) ratingTrend = 'UP';
        if (todaysAvg < allTimeAvg) ratingTrend = 'DOWN';

        return {
            id: performerId,
            name: getValueByHeader(statsRow, statsHeaders, 'performername'),
            averageRating: todaysAvg,
            ratingCount: todaysData.ratings.length,
            commentCount: todaysData.comments,
            ratingTrend: ratingTrend
        };
    }).filter(Boolean);

    leaderboard.sort((a, b) => b.averageRating - a.averageRating || b.ratingCount - a.ratingCount);
    return createSuccessResponse({ leaderboard });
}

function handleGetFeedbackTags() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(DATA_VALIDATION_SHEET_NAME);
  if (!sheet) return createErrorResponse("DataValidation sheet not found.");
  
  const data = sheet.getDataRange().getValues();
  data.shift(); // remove headers
  
  const positive = data
    .filter(row => row[0] === 'Feedback' && row[1] === 'Positive' && row[2]) // Filter for Category='Feedback', Sub Category='Positive', and non-empty tag
    .map(row => row[2]); // Get the tag from Column C

  const constructive = data
    .filter(row => row[0] === 'Feedback' && row[1] === 'Constructive' && row[2]) // Filter for Category='Feedback', Sub Category='Constructive', and non-empty tag
    .map(row => row[2]); // Get the tag from Column C

  return createSuccessResponse({ positive, constructive });
}

function handleGetRaterStats(raterEmail) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
  const raterStatsSheet = ss.getSheetByName(RATER_STATS_SHEET_NAME);
  
  const usersData = usersSheet.getDataRange().getValues();
  const usersHeadersRaw = usersData.shift();
  if (!usersHeadersRaw) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  const usersHeaders = getHeaderMap(usersHeadersRaw);
  const normalizedRaterEmail = (raterEmail || '').trim().toLowerCase();
  const userRow = usersData.find(row => getValueByHeader(row, usersHeaders, 'email').toLowerCase() === normalizedRaterEmail);
  if (!userRow) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  const userId = getValueByHeader(userRow, usersHeaders, 'userid');
  
  const statsData = raterStatsSheet.getDataRange().getValues();
  const statsHeadersRaw = statsData.shift();
  if (!statsHeadersRaw) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  const statsHeaders = getHeaderMap(statsHeadersRaw);
  const statsRow = statsData.find(row => getValueByHeader(row, statsHeaders, 'userid') === userId);
  if (!statsRow) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  
  return createSuccessResponse({
    stats: {
      totalSP: Number(getValueByHeader(statsRow, statsHeaders, 'totalsp')) || 0,
      ratingsSubmitted: Number(getValueByHeader(statsRow, statsHeaders, 'ratingssubmitted')) || 0,
      commentsWritten: Number(getValueByHeader(statsRow, statsHeaders, 'commentswritten')) || 0,
    }
  });
}

function handleGetScoutLevels() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(DATA_VALIDATION_SHEET_NAME);
  if (!sheet) return createSuccessResponse({ scoutLevels: [] });
  const data = sheet.getRange("E2:F").getValues();
  const scoutLevels = data.filter(row => row[0] && typeof row[1] === 'number')
                          .map(row => ({ name: row[0], minSP: row[1] }))
                          .sort((a, b) => a.minSP - b.minSP);
  return createSuccessResponse({ scoutLevels });
}

function handleGetFeedbackSummary(payload, timeFrame) {
    if (!API_KEY) return createErrorResponse("API key is not configured.");
    const { performerId, venueName } = payload;
    const ratingsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RATINGS_SHEET_NAME);
    const allRatings = ratingsSheet.getDataRange().getValues();
    const headersRaw = allRatings.shift();
    if (!headersRaw) return createErrorResponse("Ratings sheet is empty or missing headers.");
    const headers = getHeaderMap(headersRaw);

    const todaysDate = getTodaysDateString();

    const comments = allRatings.filter(row => {
        const rowComment = getValueByHeader(row, headers, 'comment')?.trim();
        if (getValueByHeader(row, headers, 'performeruserid') !== performerId || !rowComment) return false;
        if (timeFrame === 'today') {
            return normalizeDate(getValueByHeader(row, headers, 'timestamp')) === todaysDate &&
                   getValueByHeader(row, headers, 'venuename') === venueName;
        }
        return true;
    }).map(row => `- "${getValueByHeader(row, headers, 'comment').trim()}"`);

    if (comments.length < 2) return createErrorResponse("Not enough comments to generate a summary.");
    
    const prompt = `You are an A&R assistant providing feedback to a musician. Analyze the following anonymous comments and provide a concise, actionable summary. Start with a one-sentence summary, then list up to 3 strengths and 3 areas for improvement as bullet points. Be encouraging and constructive. Do not use markdown headers. Keep it brief. Comments:\n${comments.join('\n')}`;
    
    const response = UrlFetchApp.fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`, {
        method: 'post',
        contentType: 'application/json',
        payload: JSON.stringify({ "contents": [{ "parts": [{ "text": prompt }] }] }),
        muteHttpExceptions: true
    });
    
    const jsonResponse = JSON.parse(response.getContentText());
    if (response.getResponseCode() !== 200) {
        return createErrorResponse("AI feedback generator failed: " + (jsonResponse.error?.message || "Unknown API error."));
    }
    const summaryText = jsonResponse.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!summaryText) {
        return createErrorResponse("AI feedback generator returned an empty response.");
    }
    return createSuccessResponse({ summary: summaryText });
}

function handleDebugDateParsing() {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(EVENTS_SHEET_NAME);
    if (!sheet) return createErrorResponse("Events sheet not found for diagnostics.");
    if (sheet.getLastRow() < 2) return createSuccessResponse({ today: getTodaysDateString(), timezone: getSpreadsheetTimeZone(), debugData: [] });

    const data = sheet.getRange("B2:B" + sheet.getLastRow()).getValues();
    const debugData = data.map((row, index) => ({
        row: index + 2,
        originalDate: row[0],
        dateType: typeof row[0],
        isDateObject: row[0] instanceof Date,
        normalizedDate: normalizeDate(row[0])
    }));
    return createSuccessResponse({ today: getTodaysDateString(), timezone: getSpreadsheetTimeZone(), debugData });
}

// --- NEW EMAIL CHANGE HANDLERS ---

function handleRequestEmailChange(payload) {
    const { userId } = payload;
    const newEmail = (payload.newEmail || '').trim().toLowerCase();

    if (!userId || !newEmail || !/\S+@\S+\.\S+/.test(newEmail)) {
        return createErrorResponse("Valid User ID and new email are required.", 400);
    }
    
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        const data = usersSheet.getDataRange().getValues();
        const headersRaw = data.shift();
        const headerMap = getHeaderMap(headersRaw);
        
        const userIdIndex = headerMap['userid'];
        const emailIndex = headerMap['email'];

        const userRow = data.find(row => row[userIdIndex] === userId);
        if (!userRow) throw new Error("User not found.");

        const oldEmail = userRow[emailIndex];
        const performerName = getValueByHeader(userRow, headerMap, 'performingname') || getValueByHeader(userRow, headerMap, 'firstname');

        // Generate and store token
        const token = "E" + Utilities.getUuid().replace(/-/g, "");
        const expiry = new Date().getTime() + EMAIL_CHANGE_TOKEN_EXPIRATION_MINUTES * 60 * 1000;
        PropertiesService.getScriptProperties().setProperty(token, JSON.stringify({ userId, newEmail, expiry }));

        // Send verification email to NEW address
        const verificationUrl = `${ScriptApp.getService().getUrl()}?action=verifyEmailChange&token=${token}`;
        MailApp.sendEmail({
            to: newEmail,
            subject: "Confirm Your Email Change for UKMN",
            htmlBody: `Hello ${performerName},<br><br>Please click the link below to confirm the change of your email address for your UKMN profile. This link is valid for ${EMAIL_CHANGE_TOKEN_EXPIRATION_MINUTES} minutes.<br><br><a href="${verificationUrl}" style="padding: 10px 20px; background-color: #6d28d9; color: white; text-decoration: none; border-radius: 5px;">Confirm Email Change</a>`,
            name: "UKMN Performer Profile"
        });

        // Send notification email to OLD address
        MailApp.sendEmail({
            to: oldEmail,
            subject: "Security Alert: Email Change Request for Your UKMN Profile",
            htmlBody: `Hello ${performerName},<br><br>A request was made to change the email address associated with your UKMN profile to <strong>${newEmail}</strong>. A confirmation link has been sent to the new address.<br><br>If you did not make this request, please contact support immediately.`,
            name: "UKMN Performer Profile"
        });

        return createSuccessResponse({ message: "Verification email sent." });

    } catch (err) {
        Logger.log(`handleRequestEmailChange Error: ${err.message}\nStack: ${err.stack}`);
        return createErrorResponse(err.message);
    } finally {
        lock.releaseLock();
    }
}


function handleVerifyEmailChange(token) {
    if (!token) return HtmlService.createHtmlOutput("<h1>Error</h1><p>Invalid verification link.</p>");

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const scriptProperties = PropertiesService.getScriptProperties();
        const tokenDataString = scriptProperties.getProperty(token);
        if (!tokenDataString) return HtmlService.createHtmlOutput("<h1>Error</h1><p>This verification link is invalid or has already been used.</p>");
        
        scriptProperties.deleteProperty(token); // Use token immediately
        const tokenData = JSON.parse(tokenDataString);

        if (new Date().getTime() > tokenData.expiry) {
            return HtmlService.createHtmlOutput("<h1>Error</h1><p>This verification link has expired. Please request a new one.</p>");
        }

        const { userId, newEmail } = tokenData;

        // Update Users Sheet
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        const data = usersSheet.getDataRange().getValues();
        const headersRaw = data.shift();
        const headerMap = getHeaderMap(headersRaw);
        
        const userIdIndex = headerMap['userid'];
        const emailIndex = headerMap['email'];
        const rowIndex = data.findIndex(row => row[userIdIndex] === userId);
        if (rowIndex === -1) throw new Error("User not found during verification.");
        
        usersSheet.getRange(rowIndex + 2, emailIndex + 1).setValue(newEmail);
        
        // Update RaterStats Sheet if user exists there
        const raterStatsSheet = ss.getSheetByName(RATER_STATS_SHEET_NAME);
        if (raterStatsSheet) {
          const raterData = raterStatsSheet.getDataRange().getValues();
          const raterHeadersRaw = raterData.shift();
          const raterHeaderMap = getHeaderMap(raterHeadersRaw);
          const raterUserIdIndex = raterHeaderMap['userid'];
          const raterEmailIndex = raterHeaderMap['email'];
          const raterRowIndex = raterData.findIndex(row => row[raterUserIdIndex] === userId);
          if (raterRowIndex !== -1) {
            raterStatsSheet.getRange(raterRowIndex + 2, raterEmailIndex + 1).setValue(newEmail);
          }
        }
        
        return HtmlService.createHtmlOutput("<h1>Success!</h1><p>Your email address has been successfully updated. You can now close this window.</p>");

    } catch (err) {
        Logger.log(`handleVerifyEmailChange Error: ${err.message}\nStack: ${err.stack}`);
        return HtmlService.createHtmlOutput("<h1>Error</h1><p>An unexpected error occurred. Please try again later or contact support.</p>");
    } finally {
        lock.releaseLock();
    }
}

// =================================================================
// NEW BOOKING HANDLER FUNCTIONS
// =================================================================

function handleGetUpcomingEvents() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
  const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
  const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
  if (!eventsSheet || !venuesSheet || !bookingsSheet) {
    throw new Error("Missing required sheets for booking (Events, Venues, Bookings).");
  }
  const timezone = getSpreadsheetTimeZone();

  // 1. Cache venues and bookings
  const venuesData = venuesSheet.getDataRange().getValues();
  const venuesHeaderRaw = venuesData.shift();
  const venuesHeaders = getHeaderMap(venuesHeaderRaw);
  const venuesMap = new Map(venuesData.map(row => [getValueByHeader(row, venuesHeaders, 'venueid'), row]));
  
  const bookingsData = bookingsSheet.getDataRange().getValues();
  bookingsData.shift(); // remove headers
  const bookingsByEvent = bookingsData.reduce((acc, row) => {
    const eventId = row[1]; // Assuming EventID is column B
    if (row[4] === 'Confirmed') { // Assuming Status is column E
        if (!acc[eventId]) acc[eventId] = 0;
        acc[eventId]++;
    }
    return acc;
  }, {});

  // 2. Filter for upcoming, open events
  const now = new Date();
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const eventsData = eventsSheet.getDataRange().getValues();
  const eventsHeadersRaw = eventsData.shift();
  const eventsHeaders = getHeaderMap(eventsHeadersRaw);
  
  const upcomingEvents = eventsData.map(row => {
    const eventDateValue = getValueByHeader(row, eventsHeaders, 'eventdate');
    const bookingOpensValue = getValueByHeader(row, eventsHeaders, 'bookingopensdate');
    const bookingClosesValue = getValueByHeader(row, eventsHeaders, 'bookingclosesdate');
    const status = getValueByHeader(row, eventsHeaders, 'status') || '';

    if (!eventDateValue || !bookingOpensValue || !bookingClosesValue) return null;
    
    const eventDate = new Date(eventDateValue);
    const bookingOpens = new Date(bookingOpensValue);
    const bookingCloses = new Date(bookingClosesValue);

    // Filter logic: Event date must not be in the past. Booking must be open. Status must be 'Open'.
    if (eventDate < today || bookingOpens > now || now >= bookingCloses || status.toLowerCase() !== 'open') return null;

    const eventId = getValueByHeader(row, eventsHeaders, 'eventid');
    const totalSlots = Number(getValueByHeader(row, eventsHeaders, 'totalslotsavailable')) || 0;
    const bookedCount = bookingsByEvent[eventId] || 0;
    const venueRow = venuesMap.get(getValueByHeader(row, eventsHeaders, 'venueid'));
    
    const startTime = getValueByHeader(row, eventsHeaders, 'starttime');
    const endTime = getValueByHeader(row, eventsHeaders, 'endtime');

    let venueAddress, venueGoogleMapsLink, venueTelephone;

    if (venueRow) {
        const street = getValueByHeader(venueRow, venuesHeaders, 'street');
        const city = getValueByHeader(venueRow, venuesHeaders, 'city');
        const postcode = getValueByHeader(venueRow, venuesHeaders, 'postcode');
        venueAddress = [street, city, postcode].filter(Boolean).join(', ');
        
        const latitude = getValueByHeader(venueRow, venuesHeaders, 'latitude');
        const longitude = getValueByHeader(venueRow, venuesHeaders, 'longitude');
        if (latitude && longitude) {
            venueGoogleMapsLink = `https://www.google.com/maps?q=${latitude},${longitude}`;
        }

        venueTelephone = getValueByHeader(venueRow, venuesHeaders, 'venuephone');
    }


    return {
      id: eventId,
      venueName: venueRow ? getValueByHeader(venueRow, venuesHeaders, 'venuename') : 'Unknown Venue',
      date: normalizeDate(eventDate),
      startTime: formatSheetTime(startTime, timezone),
      endTime: formatSheetTime(endTime, timezone),
      totalSlots: totalSlots,
      availableSlots: totalSlots - bookedCount,
      venueAddress: venueAddress || undefined,
      venueGoogleMapsLink: venueGoogleMapsLink || undefined,
      venueTelephone: venueTelephone || undefined,
    };
  }).filter(Boolean).sort((a,b) => new Date(a.date) - new Date(b.date));

  return createSuccessResponse({ events: upcomingEvents });
}

function handleGetPerformerBookings(userId) {
  if (!userId) return createErrorResponse("User ID is required.", 400);

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
  const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
  const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
  
  // 1. Cache events and venues
  const eventsData = eventsSheet.getDataRange().getValues();
  const eventsHeadersRaw = eventsData.shift();
  const eventsHeaders = getHeaderMap(eventsHeadersRaw);
  const eventsMap = new Map(eventsData.map(row => [getValueByHeader(row, eventsHeaders, 'eventid'), row]));

  const venuesData = venuesSheet.getDataRange().getValues();
  const venuesHeadersRaw = venuesData.shift();
  const venuesHeaders = getHeaderMap(venuesHeadersRaw);
  const venuesMap = new Map(venuesData.map(row => [getValueByHeader(row, venuesHeaders, 'venueid'), getValueByHeader(row, venuesHeaders, 'venuename')]));

  // 2. Find user's bookings
  const bookingsData = bookingsSheet.getDataRange().getValues();
  const bookingsHeadersRaw = bookingsData.shift();
  const bookingsHeaders = getHeaderMap(bookingsHeadersRaw);
  
  const timezone = getSpreadsheetTimeZone();
  const now = new Date();
  const pastBookings = [];
  const upcomingBookings = [];

  bookingsData.forEach(row => {
    if (getValueByHeader(row, bookingsHeaders, 'userid') === userId) {
      const eventId = getValueByHeader(row, bookingsHeaders, 'eventid');
      const eventRow = eventsMap.get(eventId);
      if (!eventRow) return;

      const eventDate = new Date(getValueByHeader(eventRow, eventsHeaders, 'eventdate'));
      const booking = {
        id: getValueByHeader(row, bookingsHeaders, 'bookingid'),
        event: {
          id: eventId,
          venueName: venuesMap.get(getValueByHeader(eventRow, eventsHeaders, 'venueid')),
          date: normalizeDate(eventDate),
          startTime: formatSheetTime(getValueByHeader(eventRow, eventsHeaders, 'starttime'), timezone),
        },
        slotNumber: getValueByHeader(row, bookingsHeaders, 'slotnumber'),
        status: getValueByHeader(row, bookingsHeaders, 'status'),
      };

      if (eventDate < now) {
        pastBookings.push(booking);
      } else {
        upcomingBookings.push(booking);
      }
    }
  });

  return createSuccessResponse({ 
      upcoming: upcomingBookings.sort((a, b) => new Date(a.event.date) - new Date(a.event.date)), 
      past: pastBookings.sort((a, b) => new Date(b.event.date) - new Date(a.event.date)),
  });
}

function handleGetEventDetails(eventId) {
    if (!eventId) return createErrorResponse("Event ID is required.", 400);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);

    // Cache users
    const usersData = usersSheet.getDataRange().getValues();
    const usersHeaderRaw = usersData.shift();
    const usersHeaders = getHeaderMap(usersHeaderRaw);
    const usersMap = new Map(usersData.map(row => [getValueByHeader(row, usersHeaders, 'userid'), getValueByHeader(row, usersHeaders, 'performingname')]));
    
    // Get bookings for the event
    const bookingsData = bookingsSheet.getDataRange().getValues();
    const bookingsHeadersRaw = bookingsData.shift();
    const bookingsHeaders = getHeaderMap(bookingsHeadersRaw);
    
    const bookedSlots = bookingsData
      .filter(row => getValueByHeader(row, bookingsHeaders, 'eventid') === eventId && getValueByHeader(row, bookingsHeaders, 'status') === 'Confirmed')
      .map(row => {
        const userId = getValueByHeader(row, bookingsHeaders, 'userid');
        return {
          slotNumber: getValueByHeader(row, bookingsHeaders, 'slotnumber'),
          performer: {
            id: userId,
            name: usersMap.get(userId) || 'Unknown Performer'
          }
        };
      });

    return createSuccessResponse({ slots: bookedSlots });
}

function handleBookSlot(eventId, userId, slotNumber) {
    if (!eventId || !userId || !slotNumber) return createErrorResponse("Event, User, and Slot Number are required.", 400);

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
        const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);

        // 1. Validate event
        const eventsData = eventsSheet.getDataRange().getValues();
        const eventsHeadersRaw = eventsData.shift();
        const eventsHeaders = getHeaderMap(eventsHeadersRaw);
        const eventRow = eventsData.find(row => getValueByHeader(row, eventsHeaders, 'eventid') === eventId);
        if (!eventRow) throw new Error("Event not found.");
        const totalSlots = Number(getValueByHeader(eventRow, eventsHeaders, 'totalslotsavailable')) || 0;
        
        if (slotNumber < 1 || slotNumber > totalSlots) {
            throw new Error("Invalid slot number selected.");
        }

        // 2. Check current bookings
        const bookingsData = bookingsSheet.getDataRange().getValues();
        const bookingsHeadersRaw = bookingsData.shift();
        const bookingsHeaders = getHeaderMap(bookingsHeadersRaw);
        
        const confirmedBookingsForEvent = bookingsData.filter(row => 
            getValueByHeader(row, bookingsHeaders, 'eventid') === eventId && 
            getValueByHeader(row, bookingsHeaders, 'status') === 'Confirmed'
        );

        if (confirmedBookingsForEvent.some(row => getValueByHeader(row, bookingsHeaders, 'userid') === userId)) {
            throw new Error("You have already booked a slot for this event.");
        }
        
        // Check if the specific slot is already taken
        if (confirmedBookingsForEvent.some(row => getValueByHeader(row, bookingsHeaders, 'slotnumber') == slotNumber)) {
            throw new Error(`Slot #${slotNumber} is no longer available. Please select another.`);
        }
        
        // 3. Create new booking
        const newBookingId = `booking-${Utilities.getUuid()}`;
        
        bookingsSheet.appendRow([
            newBookingId,
            eventId,
            slotNumber,
            userId,
            'Confirmed',
            getFormattedDateTime(new Date()),
            '' // Notes
        ]);

        return createSuccessResponse({ message: `Successfully booked slot #${slotNumber}.`, slotNumber: slotNumber });

    } catch (err) {
        Logger.log(`handleBookSlot Error: ${err.message}`);
        return createErrorResponse(err.message);
    } finally {
        lock.releaseLock();
    }
}

function handleCancelBooking(bookingId, userId) {
    // 1. Log incoming data
    Logger.log(`--- handleCancelBooking initiated ---`);
    Logger.log(`Received bookingId: ${bookingId} (type: ${typeof bookingId})`);
    Logger.log(`Received userId: ${userId} (type: ${typeof userId})`);

    if (!bookingId || !userId) {
        Logger.log("Error: Missing bookingId or userId.");
        return createErrorResponse("Booking and User ID are required.", 400);
    }

    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const bookingsSheet = ss.getSheetByName(BOOKINGS_SHEET_NAME);
        if (!bookingsSheet) throw new Error("Bookings sheet not found.");
        
        const data = bookingsSheet.getDataRange().getValues();
        if (data.length < 2) throw new Error("Bookings sheet is empty or contains no data.");

        const headersRaw = data.shift();
        const headerMap = getHeaderMap(headersRaw);
        
        // 2. Log header map and column indices
        Logger.log(`Header Map: ${JSON.stringify(headerMap)}`);
        const bookingIdCol = headerMap['bookingid'];
        const userIdCol = headerMap['userid'];
        const statusCol = headerMap['status'];
        Logger.log(`Column Indices -> bookingId: ${bookingIdCol}, userId: ${userIdCol}, status: ${statusCol}`);

        if ([bookingIdCol, userIdCol, statusCol].includes(undefined)) {
            throw new Error("Could not find required columns (BookingID, UserID, Status) in Bookings sheet.");
        }
        
        let rowIndexToUpdate = -1;
        let foundBookingButNotUser = false;
        let unauthorizedUserId = null;

        for (let i = 0; i < data.length; i++) {
            const row = data[i];
            const sheetBookingId = row[bookingIdCol];
            const sheetUserId = row[userIdCol];
            
            // Using strict equality `===` and trimming whitespace is safer.
            if (String(sheetBookingId).trim() === String(bookingId).trim()) {
                Logger.log(`Row ${i+2}: BookingID matched. Now checking UserID.`);
                Logger.log(`Row ${i+2}: Comparing sheet UserID '${sheetUserId}' with '${userId}'.`);

                if (String(sheetUserId).trim() === String(userId).trim()) {
                    rowIndexToUpdate = i + 2; // +1 for 0-based index, +1 for the header row
                    Logger.log(`Row ${i+2}: UserID matched. Setting rowIndexToUpdate to ${rowIndexToUpdate}.`);
                    break;
                } else {
                    foundBookingButNotUser = true;
                    unauthorizedUserId = sheetUserId;
                    Logger.log(`Row ${i+2}: UserID did NOT match. Expected '${userId}', but found '${sheetUserId}'.`);
                    break; 
                }
            }
        }
        
        if (foundBookingButNotUser) {
            throw new Error(`You are not authorized to cancel this booking.`);
        }
        
        if (rowIndexToUpdate > -1) {
            Logger.log(`Updating sheet at row ${rowIndexToUpdate}, column ${statusCol + 1} to 'Cancelled'.`);
            bookingsSheet.getRange(rowIndexToUpdate, statusCol + 1).setValue('Cancelled');
            SpreadsheetApp.flush(); // Force changes to be written immediately before returning.
            Logger.log(`--- handleCancelBooking success ---`);
            return createSuccessResponse({ message: "Booking successfully cancelled." });
        } else {
            Logger.log(`Loop finished. No matching booking found for bookingId: ${bookingId}.`);
            throw new Error("Booking not found. It may have already been cancelled or does not exist.");
        }

    } catch (err) {
        Logger.log(`!!! handleCancelBooking Error: ${err.message}`);
        Logger.log(`Stack: ${err.stack}`);
        return createErrorResponse(err.message);
    } finally {
        lock.releaseLock();
    }
}