// =================================================================
// CONFIGURATION
// =================================================================

// IMPORTANT: Replace this with the URL of your deployed frontend web app.
const WEB_APP_URL = 'https://rate.ukmusiciansnetwork.com'; 

// --- Sheet Names ---
const PERFORMERS_SHEET_NAME = 'Performers';
const RATERS_SHEET_NAME = 'Raters';
const RATINGS_SHEET_NAME = 'Ratings';
const TAGS_SHEET_NAME = 'Data Validation'; // New sheet for dynamic tags

// --- Token Expiration (in minutes) ---
const TOKEN_EXPIRATION_MINUTES = 15;

// --- Gemini API Configuration ---
// IMPORTANT: You must set your Gemini API key in the script's properties.
// 1. Go to Project Settings (gear icon).
// 2. Scroll to "Script Properties" and click "Add script property".
// 3. Set the Property name to "API_KEY" and the Value to your key.
const API_KEY = PropertiesService.getScriptProperties().getProperty('API_KEY');


// =================================================================
// UTILITY FUNCTIONS
// =================================================================

/**
 * Calls the Gemini API to generate content based on a prompt.
 * @param {string} prompt The text prompt to send to the model.
 * @return {string} The text response from the model.
 */
function callGeminiApi(prompt) {
  if (!API_KEY) {
    throw new Error("Gemini API key is not set. Please configure it in the script properties.");
  }
  
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`;
  
  const payload = {
    contents: [{
      parts: [{
        text: prompt
      }]
    }]
  };
  
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true // Prevents script from halting on API errors
  };

  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  const responseBody = response.getContentText();

  if (responseCode === 200) {
    const jsonResponse = JSON.parse(responseBody);
    // Safely access the text from the response
    const text = jsonResponse.candidates?.[0]?.content?.parts?.[0]?.text;
    if (text) {
      return text;
    } else {
      Logger.log(`Gemini response missing text content. Full Response: ${responseBody}`);
      throw new Error("Failed to extract summary from Gemini's response.");
    }
  } else {
    Logger.log(`Gemini API Error (Code: ${responseCode}): ${responseBody}`);
    throw new Error(`Gemini API request failed with status ${responseCode}. Check the logs for details.`);
  }
}

/**
 * Creates a JSON response object for the web app.
 * @param {object} data The data to be returned.
 * @return {ContentService.TextOutput} The JSON response.
 */
function createJsonResponse(data) {
  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}


/**
 * Normalizes a date value from a sheet cell into a 'yyyy-MM-dd' string,
 * correctly handling timezone conversions to prevent day-shifting bugs.
 * @param {Date|string|number} dateValue The value from the spreadsheet cell.
 * @param {string} timezone The timezone of the spreadsheet.
 * @return {string|null} The formatted date string or null if invalid.
 */
function normalizeDateString(dateValue, timezone) {
  if (!dateValue || dateValue === '') return null;

  // Case 1: The value is already a JavaScript Date object. This is the ideal case.
  if (dateValue instanceof Date) {
    return Utilities.formatDate(dateValue, timezone, 'yyyy-MM-dd');
  }

  // Case 2: The value is a string. This requires careful parsing.
  if (typeof dateValue === 'string') {
    const trimmedDate = dateValue.trim();
    
    // Check for ISO 8601 format (YYYY-MM-DD), which JS parses as UTC.
    // We must manually adjust it to treat it as a local date in the script's timezone.
    const isoMatch = trimmedDate.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (isoMatch) {
      const year = parseInt(isoMatch[1], 10);
      const month = parseInt(isoMatch[2], 10) - 1; // Month is 0-indexed
      const day = parseInt(isoMatch[3], 10);
      // Constructing the date from parts ensures it's interpreted in the script's local timezone, not UTC.
      const localDate = new Date(year, month, day);
      return Utilities.formatDate(localDate, timezone, 'yyyy-MM-dd');
    }
  }

  // Case 3: Fallback for other string formats (e.g., 'Jul 26, 2024') or numbers (Sheet serial dates).
  // new Date() can handle these, but we proceed with caution.
  try {
    const parsedDate = new Date(dateValue);
    // Check if parsing resulted in a valid date.
    if (isNaN(parsedDate.getTime())) {
      Logger.log(`Could not parse date value: "${dateValue}" into a valid date.`);
      return null;
    }
    return Utilities.formatDate(parsedDate, timezone, 'yyyy-MM-dd');
  } catch (e) {
    Logger.log(`Exception while parsing date value "${dateValue}": ${e.message}`);
    return null;
  }
}


// =================================================================
// MAIN ENDPOINT - doPost
// =================================================================

function doPost(e) {
  try {
    const payload = JSON.parse(e.postData.contents);
    let responseData;

    switch (payload.action) {
      case 'getVenuesForToday':
        responseData = handleGetVenuesForToday();
        break;
      case 'getPerformers':
        responseData = handleGetPerformers(payload);
        break;
      case 'requestLogin':
        responseData = handleRequestLogin(payload);
        break;
      case 'verifyToken':
        responseData = handleVerifyToken(payload);
        break;
      case 'getTodaysRatings':
        responseData = handleGetTodaysRatings(payload);
        break;
      case 'submitRatings':
        responseData = handleSubmitRatings(payload);
        break;
      case 'getLeaderboardData':
        responseData = handleGetLeaderboardData(payload);
        break;
      case 'getFeedbackTags':
        responseData = handleGetFeedbackTags();
        break;
      case 'getFeedbackSummary': // New action for Gemini
        responseData = handleGetFeedbackSummary(payload);
        break;
      case 'debugDateParsing':
        responseData = handleDebugDateParsing();
        break;
      default:
        throw new Error(`Unknown action: ${payload.action}`);
    }

    return createJsonResponse({ status: 'success', ...responseData });
  } catch (error) {
    Logger.log(`Error in doPost: ${error.message}\nStack: ${error.stack}`);
    return createJsonResponse({ status: 'error', message: `Script Error: ${error.message}` });
  }
}

// =================================================================
// ACTION HANDLERS
// =================================================================

/**
 * Gets all comments for a specific performer for today, sends them to Gemini for summarization.
 */
function handleGetFeedbackSummary(payload) {
  const { performerId, venueName } = payload;
  if (!performerId || !venueName) throw new Error("performerId and venueName are required for summary.");

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(RATINGS_SHEET_NAME);

  if (!sheet || sheet.getLastRow() < 2) {
    return { summary: "No ratings data found." };
  }

  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
  const spreadsheetTimezone = ss.getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');

  const comments = [];
  data.forEach(row => {
    const timestampString = normalizeDateString(row[0], spreadsheetTimezone);
    const currentVenueName = row[4];
    const currentPerformerId = row[5];
    const comment = row[11]; // Column L is Comments

    if (timestampString === todayString && currentVenueName === venueName && currentPerformerId.toString() === performerId.toString() && comment && comment.trim() !== '') {
      comments.push(comment.trim());
    }
  });

  if (comments.length < 2) {
    return { summary: "Not enough comments available to generate a meaningful summary." };
  }
  
  const prompt = `Please summarize the following feedback comments for a music performer. Generate a concise, bulleted list highlighting the key positive themes and areas for improvement. The summary should be constructive and helpful for the artist.

Comments:
- "${comments.join('"\n- "')}"

Summary:`;

  const summary = callGeminiApi(prompt);
  return { summary };
}

/**
 * Fetches feedback tags and their types from the 'Data Validation' sheet.
 */
function handleGetFeedbackTags() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(TAGS_SHEET_NAME);
  if (!sheet || sheet.getLastRow() < 2) {
    return { positive: [], constructive: [] };
  }
  
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 2).getValues();
  
  const positive = [];
  const constructive = [];

  data.forEach(row => {
    const tag = row[0];
    const type = row[1];
    if (tag && type) {
      if (type.toLowerCase() === 'positive') {
        positive.push(tag);
      } else if (type.toLowerCase() === 'constructive') {
        constructive.push(tag);
      }
    }
  });

  return { positive, constructive };
}


/**
 * Calculates and returns the top-rated performers for a specific venue for today.
 * Now also includes a count of comments, bio, and social link for each performer.
 */
function handleGetLeaderboardData(payload) {
  const { venueName } = payload;
  if (!venueName) throw new Error("venueName is required for leaderboard data.");

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const spreadsheetTimezone = ss.getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');

  // Step 1: Create a map of performer info for today's venue
  const performersSheet = ss.getSheetByName(PERFORMERS_SHEET_NAME);
  const performerInfoMap = {};
  if (performersSheet && performersSheet.getLastRow() > 1) {
    const performerValues = performersSheet.getRange(2, 1, performersSheet.getLastRow() - 1, 6).getValues(); // Get up to column F (social link)
    performerValues.forEach(row => {
      const id = row[0];
      const venue = row[2];
      const dateValue = row[3];
      const dateString = normalizeDateString(dateValue, spreadsheetTimezone);
      if (id && venue === venueName && dateString === todayString) {
        performerInfoMap[id.toString()] = {
          bio: row[4] || '',
          socialLink: row[5] || ''
        };
      }
    });
  }

  // Step 2: Process ratings
  const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
  if (!ratingsSheet || ratingsSheet.getLastRow() < 2) {
    return { leaderboard: [] };
  }
  const ratingsData = ratingsSheet.getRange(2, 1, ratingsSheet.getLastRow() - 1, ratingsSheet.getLastColumn()).getValues();
  
  const ratingsByPerformer = {};
  ratingsData.forEach(row => {
    const timestampString = normalizeDateString(row[0], spreadsheetTimezone);
    const currentVenueName = row[4];
    
    if (timestampString === todayString && currentVenueName === venueName) {
      const performerId = row[5].toString();
      const performerName = row[6];
      const ratingValue = parseFloat(row[7]);
      const comment = row[11] || '';

      if (!ratingsByPerformer[performerId]) {
        const info = performerInfoMap[performerId] || { bio: '', socialLink: '' }; // Fallback
        ratingsByPerformer[performerId] = {
          id: performerId,
          name: performerName,
          totalRating: 0,
          ratingCount: 0,
          commentCount: 0,
          bio: info.bio,
          socialLink: info.socialLink
        };
      }
      
      if (!isNaN(ratingValue)) {
        ratingsByPerformer[performerId].totalRating += ratingValue;
        ratingsByPerformer[performerId].ratingCount += 1;
      }
      if (comment.trim() !== '') {
        ratingsByPerformer[performerId].commentCount += 1;
      }
    }
  });

  const leaderboard = Object.values(ratingsByPerformer).map(p => ({
    ...p,
    averageRating: p.ratingCount > 0 ? (p.totalRating / p.ratingCount) : 0,
  }));
  
  leaderboard.sort((a, b) => {
    if (b.averageRating !== a.averageRating) {
      return b.averageRating - a.averageRating;
    }
    return b.ratingCount - a.ratingCount;
  });

  return { leaderboard: leaderboard.slice(0, 3) };
}


/**
 * Finds all unique venues with performances scheduled for today.
 */
function handleGetVenuesForToday() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PERFORMERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${PERFORMERS_SHEET_NAME}" not found.`);

  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4).getValues();
  
  const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');
  
  const venues = new Set();
  data.forEach((row, index) => {
    const venueName = row[2];
    const performanceDateValue = row[3];
    const performanceDateString = normalizeDateString(performanceDateValue, spreadsheetTimezone);

    if (venueName && performanceDateString && performanceDateString === todayString) {
      venues.add(venueName);
    }
  });

  return { venues: Array.from(venues) };
}


/**
 * Gets all performers for a specific venue for today.
 */
function handleGetPerformers(payload) {
    if (!payload.venueName) throw new Error("venueName is required.");

    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PERFORMERS_SHEET_NAME);
    if (!sheet) throw new Error(`Sheet "${PERFORMERS_SHEET_NAME}" not found.`);

    if (sheet.getLastRow() < 2) {
      return { performers: [] };
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
    const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');

    const performers = data.filter(row => {
        const venueName = row[2];
        const performanceDateValue = row[3];
        if (!venueName || venueName.trim() !== payload.venueName.trim()) {
            return false;
        }
        const performanceDateString = normalizeDateString(performanceDateValue, spreadsheetTimezone);
        return performanceDateString === todayString;
    }).map(row => ({
        id: row[0],
        name: row[1],
        bio: row[4] || '',
        socialLink: row[5] || '',
        setTime: row[6] || ''
    }));
    
    return { performers };
}


/**
 * Generates a login token and emails a magic link to the user.
 */
function handleRequestLogin(payload) {
  const { email, firstName, lastName, venueName } = payload;
  if (!email || !firstName || !lastName || !venueName) {
    throw new Error("Missing required fields for login request.");
  }

  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RATERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${RATERS_SHEET_NAME}" not found.`);

  const token = Utilities.getUuid();
  const expiry = new Date(new Date().getTime() + TOKEN_EXPIRATION_MINUTES * 60 * 1000);
  
  const data = sheet.getDataRange().getValues();
  let raterRow = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === email) {
      raterRow = i + 1;
      break;
    }
  }

  if (raterRow !== -1) {
    sheet.getRange(raterRow, 1, 1, 6).setValues([[email, firstName, lastName, venueName, token, expiry]]);
  } else {
    sheet.appendRow([email, firstName, lastName, venueName, token, expiry]);
  }
  
  const loginUrl = `${WEB_APP_URL}?token=${token}`;
  
  const today = new Date();
  const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
  const formattedDate = Utilities.formatDate(today, spreadsheetTimezone, 'dd MMM');
  
  const subject = `[${formattedDate}] ${firstName}, Your Secure Login Link To Rate Performers At ${venueName}`;
  
  const body = `
    <html>
      <body>
        <h2>Hello ${firstName},</h2>
        <p>Click the link below to securely log in and start rating performers at ${venueName}.</p>
        <p><a href="${loginUrl}" style="font-size: 16px; font-weight: bold; color: white; background-color: #6d28d9; padding: 12px 24px; text-decoration: none; border-radius: 25px;">Log In Now</a></p>
        <p>This link is valid for ${TOKEN_EXPIRATION_MINUTES} minutes and can only be used once.</p>
        <p>If you did not request this link, you can safely ignore this email.</p>
      </body>
    </html>`;
  
  MailApp.sendEmail({
    to: email,
    from: 'team@ukmusiciansnetwork.com',
    subject: subject,
    htmlBody: body,
  });

  return { message: 'Login link sent.' };
}


/**
 * Verifies a login token and returns user details.
 */
function handleVerifyToken(payload) {
  const { token } = payload;
  if (!token) throw new Error("Token is required for verification.");

  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RATERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${RATERS_SHEET_NAME}" not found.`);

  const data = sheet.getDataRange().getValues();
  
  let raterInfo = null;
  for (let i = 1; i < data.length; i++) {
    if (data[i][4] === token) { // Column E is Auth Token
      const expiryDate = new Date(data[i][5]); // Column F is Token Expiry
      if (expiryDate.getTime() > new Date().getTime()) {
        raterInfo = {
          email: data[i][0],
          firstName: data[i][1],
          lastName: data[i][2],
          venue: data[i][3],
        };
        sheet.getRange(i + 1, 5, 1, 2).setValues([["", ""]]);
      }
      break;
    }
  }

  if (raterInfo) {
    return raterInfo;
  } else {
    throw new Error("Invalid or expired token.");
  }
}

/**
 * Retrieves all ratings submitted by a specific rater for a specific venue today.
 */
function handleGetTodaysRatings(payload) {
    const { raterEmail, venueName } = payload;
    if (!raterEmail || !venueName) throw new Error("raterEmail and venueName are required.");

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(RATINGS_SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      return { ratings: {} };
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    const spreadsheetTimezone = ss.getSpreadsheetTimeZone();
    const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');
    
    const ratings = {};
    data.forEach(row => {
        const timestampString = normalizeDateString(row[0], spreadsheetTimezone);
        const currentRaterEmail = row[1];
        const currentVenueName = row[4];
        
        if (timestampString === todayString && currentRaterEmail === raterEmail && currentVenueName === venueName) {
            const performerId = row[5];
            const ratingValue = row[7];
            ratings[performerId] = ratingValue;
        }
    });

    return { ratings };
}


/**
 * Submits new ratings to the spreadsheet.
 */
function handleSubmitRatings(payload) {
  const { ratings, raterEmail, firstName, lastName, venueName, latitude, longitude } = payload;
  if (!ratings || !raterEmail || !venueName || !firstName || !lastName) {
    throw new Error("Missing required fields for submitting ratings.");
  }
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
  if (!ratingsSheet) throw new Error(`Sheet "${RATINGS_SHEET_NAME}" not found.`);

  const performersSheet = ss.getSheetByName(PERFORMERS_SHEET_NAME);
  const performerData = performersSheet.getRange(2, 1, performersSheet.getLastRow() - 1, 2).getValues();
  const performerNameMap = performerData.reduce((map, row) => {
    map[row[0]] = row[1];
    return map;
  }, {});

  const timestamp = new Date();
  
  const rowsToAdd = ratings.map(rating => {
    const performerName = performerNameMap[rating.id] || 'Performer Not Found';
    return [
      timestamp,
      raterEmail,
      firstName,
      lastName,
      venueName,
      rating.id,
      performerName,
      rating.rating,
      (rating.feedbackTags || []).join(', '),
      latitude || '',
      longitude || '',
      rating.comment || ''
    ];
  });
  
  if (rowsToAdd.length > 0) {
      ratingsSheet.getRange(ratingsSheet.getLastRow() + 1, 1, rowsToAdd.length, rowsToAdd[0].length).setValues(rowsToAdd);
  }

  return { message: 'Ratings submitted successfully.' };
}

/**
 * A diagnostic function to help debug date parsing issues.
 */
function handleDebugDateParsing() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PERFORMERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${PERFORMERS_SHEET_NAME}" not found.`);
  
  const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');
  
  const numRowsToFetch = Math.min(sheet.getLastRow(), 16);
  if (numRowsToFetch < 2) {
    return { 
        today: todayString,
        timezone: spreadsheetTimezone,
        debugData: [{ row: 0, originalDate: 'Sheet is empty or has no data rows.', normalizedDate: 'N/A'}]
    };
  }

  const data = sheet.getRange(2, 4, numRowsToFetch - 1, 1).getValues();
  
  const debugData = data.map((row, index) => {
    const dateValue = row[0];
    return {
      row: index + 2,
      originalDate: dateValue,
      dateType: typeof dateValue,
      isDateObject: dateValue instanceof Date,
      normalizedDate: normalizeDateString(dateValue, spreadsheetTimezone),
    };
  });
  
  return { 
    today: todayString,
    timezone: spreadsheetTimezone,
    debugData: debugData
  };
}