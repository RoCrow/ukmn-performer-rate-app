// =================================================================
// CONFIGURATION
// =================================================================

// IMPORTANT: Replace this with the URL of your deployed frontend web app.
const WEB_APP_URL = 'https://rate.ukmusiciansnetwork.com'; 

// --- Sheet Names ---
const PERFORMERS_SHEET_NAME = 'Performers';
const RATERS_SHEET_NAME = 'Raters';
const RATINGS_SHEET_NAME = 'Ratings';
const TAGS_SHEET_NAME = 'Data Validation'; // New sheet for dynamic tags

// --- Token Expiration (in minutes) ---
const TOKEN_EXPIRATION_MINUTES = 15;

// --- Gemini API Configuration ---
// IMPORTANT: You must set your Gemini API key in the script's properties.
// 1. Go to Project Settings (gear icon).
// 2. Scroll to "Script Properties" and click "Add script property".
// 3. Set the Property name to "API_KEY" and the Value to your key.
const API_KEY = PropertiesService.getScriptProperties().getProperty('API_KEY');


// =================================================================
// UTILITY FUNCTIONS
// =================================================================

/**
 * Calls the Gemini API to generate content based on a prompt.
 * @param {string} prompt The text prompt to send to the model.
 * @return {string} The text response from the model.
 */
function callGeminiApi(prompt) {
  if (!API_KEY) {
    throw new Error("Gemini API key is not set. Please configure it in the script properties.");
  }
  
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`;
  
  const payload = {
    contents: [{
      parts: [{
        text: prompt
      }]
    }]
  };
  
  const options = {
    method: 'post',
    contentType: 'application/json',
    payload: JSON.stringify(payload),
    muteHttpExceptions: true // Prevents script from halting on API errors
  };

  const response = UrlFetchApp.fetch(url, options);
  const responseCode = response.getResponseCode();
  const responseBody = response.getContentText();

  if (responseCode === 200) {
    const jsonResponse = JSON.parse(responseBody);
    
    // Check for content, but also for reasons why content might be missing (e.g., safety)
    const candidate = jsonResponse.candidates?.[0];
    if (candidate && candidate.content?.parts?.[0]?.text) {
      return candidate.content.parts[0].text;
    } else {
      const finishReason = candidate?.finishReason || "UNKNOWN";
      const safetyRatings = JSON.stringify(candidate?.safetyRatings || "Not provided");
      Logger.log(`Gemini response was successful (200) but lacked text content.`);
      Logger.log(`Finish Reason: ${finishReason}. Safety Ratings: ${safetyRatings}.`);
      Logger.log(`Full Response Body: ${responseBody}`);
      throw new Error(`Gemini returned an empty response. This may be due to safety filters (Reason: ${finishReason}). Check script logs for the full API response.`);
    }
  } else {
    // This block handles API errors (4xx, 5xx) and provides detailed messages.
    Logger.log(`Gemini API Error (Code: ${responseCode}): ${responseBody}`);
    let errorMessage = `Gemini API request failed with status ${responseCode}.`;
    try {
      // Try to parse the error response from Google for a more specific message
      const errorJson = JSON.parse(responseBody);
      const specificError = errorJson?.error?.message;
      if (specificError) {
        errorMessage += ` Details: ${specificError}`;
      }
    } catch (e) {
      // The error response wasn't JSON, just append the raw text
      errorMessage += ` Response: ${responseBody}`;
    }
    throw new Error(errorMessage);
  }
}

/**
 * Creates a JSON response object for the web app.
 * @param {object} data The data to be returned.
 * @return {ContentService.TextOutput} The JSON response.
 */
function createJsonResponse(data) {
  return ContentService.createTextOutput(JSON.stringify(data))
    .setMimeType(ContentService.MimeType.JSON);
}


/**
 * Parses a 'DD/MM/YYYY...' formatted string into a JavaScript Date object.
 * @param {string} dateString The string to parse.
 * @return {Date|null} The parsed Date object or null if invalid.
 */
function parseDMYDate(dateString) {
  if (typeof dateString !== 'string') return null;
  const match = dateString.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
  if (match) {
    const day = parseInt(match[1], 10);
    const month = parseInt(match[2], 10) - 1; // JS months are 0-indexed
    const year = parseInt(match[3], 10);
    // Basic validation
    if (year > 1900 && month >= 0 && month < 12 && day > 0 && day <= 31) {
      // We only care about the date part for matching "today"
      return new Date(year, month, day);
    }
  }
  return null;
}


/**
 * Normalizes a date value from a sheet cell into a 'yyyy-MM-dd' string,
 * correctly handling timezone conversions to prevent day-shifting bugs.
 * @param {Date|string|number} dateValue The value from the spreadsheet cell.
 * @param {string} timezone The timezone of the spreadsheet.
 * @return {string|null} The formatted date string or null if invalid.
 */
function normalizeDateString(dateValue, timezone) {
  if (!dateValue || dateValue === '') return null;

  // Case 1: The value is already a JavaScript Date object. This is the ideal case.
  if (dateValue instanceof Date) {
    return Utilities.formatDate(dateValue, timezone, 'yyyy-MM-dd');
  }

  // Case 2: The value is a string. This requires careful parsing.
  if (typeof dateValue === 'string') {
    const trimmedDate = dateValue.trim();
    
    // Attempt to parse our custom 'DD/MM/YYYY HH:mm:ss' format first
    const dmyDate = parseDMYDate(trimmedDate);
    if (dmyDate) {
      return Utilities.formatDate(dmyDate, timezone, 'yyyy-MM-dd');
    }
    
    // Check for ISO 8601 format (YYYY-MM-DD), which JS parses as UTC.
    const isoMatch = trimmedDate.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (isoMatch) {
      const year = parseInt(isoMatch[1], 10);
      const month = parseInt(isoMatch[2], 10) - 1; // Month is 0-indexed
      const day = parseInt(isoMatch[3], 10);
      // Constructing the date from parts ensures it's interpreted in the script's local timezone, not UTC.
      const localDate = new Date(year, month, day);
      return Utilities.formatDate(localDate, timezone, 'yyyy-MM-dd');
    }
  }

  // Case 3: Fallback for other string formats (e.g., 'Jul 26, 2024') or numbers (Sheet serial dates).
  try {
    const parsedDate = new Date(dateValue);
    // Check if parsing resulted in a valid date.
    if (isNaN(parsedDate.getTime())) {
      Logger.log(`Could not parse date value: "${dateValue}" into a valid date.`);
      return null;
    }
    return Utilities.formatDate(parsedDate, timezone, 'yyyy-MM-dd');
  } catch (e) {
    Logger.log(`Exception while parsing date value "${dateValue}": ${e.message}`);
    return null;
  }
}


// =================================================================
// MAIN ENDPOINT - doPost
// =================================================================

function doPost(e) {
  try {
    const payload = JSON.parse(e.postData.contents);
    let responseData;

    switch (payload.action) {
      case 'getVenuesForToday':
        responseData = handleGetVenuesForToday();
        break;
      case 'getPerformers':
        responseData = handleGetPerformers(payload);
        break;
      case 'requestLogin':
        responseData = handleRequestLogin(payload);
        break;
      case 'verifyToken':
        responseData = handleVerifyToken(payload);
        break;
      case 'getTodaysRatings':
        responseData = handleGetTodaysRatings(payload);
        break;
      case 'submitRatings':
        responseData = handleSubmitRatings(payload);
        break;
      case 'getLeaderboardData':
        responseData = handleGetLeaderboardData(payload);
        break;
      case 'getFeedbackTags':
        responseData = handleGetFeedbackTags();
        break;
      case 'getFeedbackSummary': // New action for Gemini
        responseData = handleGetFeedbackSummary(payload);
        break;
      case 'debugDateParsing':
        responseData = handleDebugDateParsing();
        break;
      default:
        throw new Error(`Unknown action: ${payload.action}`);
    }

    return createJsonResponse({ status: 'success', ...responseData });
  } catch (error) {
    const requestPayload = e && e.postData && e.postData.contents ? e.postData.contents : 'Payload not available';
    Logger.log(`--- SCRIPT ERROR ---`);
    Logger.log(`Action that failed: ${JSON.parse(requestPayload).action || 'Unknown'}`);
    Logger.log(`Full Request Payload: ${requestPayload}`);
    Logger.log(`Error Message: ${error.message}`);
    Logger.log(`Error Stack: ${error.stack}`);
    Logger.log(`--- END SCRIPT ERROR ---`);
    return createJsonResponse({ status: 'error', message: `Script Error: ${error.message}` });
  }
}

// =================================================================
// ACTION HANDLERS
// =================================================================

/**
 * Gets all comments for a specific performer for today, sends them to Gemini for summarization.
 * Implements caching to avoid redundant API calls.
 */
function handleGetFeedbackSummary(payload) {
  const { performerId, venueName } = payload;
  if (!performerId || !venueName) {
    throw new Error("performerId and venueName are required for summary.");
  }
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const spreadsheetTimezone = ss.getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');

  // --- 1. Fetch current comments and count them ---
  const sheet = ss.getSheetByName(RATINGS_SHEET_NAME);
  if (!sheet || sheet.getLastRow() < 2) {
    return { summary: "No ratings data found." };
  }
  
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
  const comments = [];
  data.forEach(row => {
    const timestampString = normalizeDateString(row[0], spreadsheetTimezone);
    const currentVenueName = row[4];
    const currentPerformerId = row[5];
    const comment = row[11]; // Column L is Comments

    if (timestampString === todayString && 
        currentVenueName && currentVenueName.trim().toLowerCase() === venueName.trim().toLowerCase() && 
        currentPerformerId.toString() === performerId.toString() && 
        comment && comment.trim() !== '') {
      comments.push(comment.trim());
    }
  });

  const currentCommentCount = comments.length;
  Logger.log(`[Feedback Summary] PerformerId: ${performerId}. Current comment count: ${currentCommentCount}`);

  // --- 2. Check Cache ---
  const cache = CacheService.getScriptCache();
  const cacheKey = `summary_${venueName.replace(/\s/g, '_')}_${performerId}_${todayString}`;
  const cachedResult = cache.get(cacheKey);

  if (cachedResult) {
    const cachedData = JSON.parse(cachedResult);
    if (cachedData.commentCount === currentCommentCount) {
      Logger.log(`[Feedback Summary] CACHE HIT for key: ${cacheKey}`);
      return { summary: cachedData.summary };
    } else {
      Logger.log(`[Feedback Summary] CACHE STALE for key: ${cacheKey}. Cached count: ${cachedData.commentCount}, current count: ${currentCommentCount}. Regenerating.`);
    }
  } else {
      Logger.log(`[Feedback Summary] CACHE MISS for key: ${cacheKey}`);
  }

  // --- 3. Generate New Summary if Needed ---
  if (currentCommentCount < 2) {
    return { summary: "Not enough comments available to generate a meaningful summary." };
  }
  
  const prompt = `Please summarize the following feedback comments for a music performer. Generate a concise, bulleted list highlighting the key positive themes and areas for improvement. The summary should be constructive and helpful for the artist.

Comments:
- "${comments.join('"\n- "')}"

Summary:`;

  const newSummary = callGeminiApi(prompt);
  
  // --- 4. Store in Cache ---
  const dataToCache = {
    summary: newSummary,
    commentCount: currentCommentCount
  };
  // Cache for 6 hours (21600 seconds)
  cache.put(cacheKey, JSON.stringify(dataToCache), 21600);
  Logger.log(`[Feedback Summary] Stored new summary in cache for key: ${cacheKey}`);

  return { summary: newSummary };
}

/**
 * Fetches feedback tags and their types from the 'Data Validation' sheet.
 */
function handleGetFeedbackTags() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(TAGS_SHEET_NAME);
  if (!sheet || sheet.getLastRow() < 2) {
    return { positive: [], constructive: [] };
  }
  
  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 2).getValues();
  
  const positive = [];
  const constructive = [];

  data.forEach(row => {
    const tag = row[0];
    const type = row[1];
    if (tag && type) {
      if (type.toLowerCase() === 'positive') {
        positive.push(tag);
      } else if (type.toLowerCase() === 'constructive') {
        constructive.push(tag);
      }
    }
  });

  return { positive, constructive };
}


/**
 * Calculates and returns stats for all scheduled performers for a specific venue for today.
 */
function handleGetLeaderboardData(payload) {
  const { venueName } = payload;
  if (!venueName) throw new Error("venueName is required for leaderboard data.");

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const spreadsheetTimezone = ss.getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');

  // Step 1: Get all performers scheduled for today at this venue and initialize their stats.
  const performersSheet = ss.getSheetByName(PERFORMERS_SHEET_NAME);
  const ratingsByPerformer = {};

  if (performersSheet && performersSheet.getLastRow() > 1) {
    const performerValues = performersSheet.getRange(2, 1, performersSheet.getLastRow() - 1, 6).getValues(); // Get up to social link
    performerValues.forEach(row => {
      const id = row[0];
      const name = row[1];
      const venue = row[2];
      const dateValue = row[3];
      const dateString = normalizeDateString(dateValue, spreadsheetTimezone);
      
      if (id && name && venue && venue.trim().toLowerCase() === venueName.trim().toLowerCase() && dateString === todayString) {
        ratingsByPerformer[id.toString()] = {
          id: id.toString(),
          name: name,
          totalRating: 0,
          ratingCount: 0,
          commentCount: 0,
          bio: row[4] || '',
          socialLink: row[5] || ''
        };
      }
    });
  }

  // Step 2: Process the Ratings sheet and update the stats.
  const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
  if (ratingsSheet && ratingsSheet.getLastRow() > 1) {
    const ratingsData = ratingsSheet.getRange(2, 1, ratingsSheet.getLastRow() - 1, ratingsSheet.getLastColumn()).getValues();
    
    ratingsData.forEach(row => {
      const timestampString = normalizeDateString(row[0], spreadsheetTimezone);
      const currentVenueName = row[4];
      
      if (timestampString === todayString && currentVenueName && currentVenueName.trim().toLowerCase() === venueName.trim().toLowerCase()) {
        const performerId = row[5].toString();
        const ratingValue = parseFloat(row[7]);
        const comment = row[11] || '';

        // Check if this performer is in our list for today
        if (ratingsByPerformer[performerId]) {
          if (!isNaN(ratingValue)) {
            ratingsByPerformer[performerId].totalRating += ratingValue;
            ratingsByPerformer[performerId].ratingCount += 1;
          }
          if (comment.trim() !== '') {
            ratingsByPerformer[performerId].commentCount += 1;
          }
        }
      }
    });
  }

  // Step 3: Calculate average and sort.
  const leaderboard = Object.values(ratingsByPerformer).map(p => ({
    ...p,
    averageRating: p.ratingCount > 0 ? (p.totalRating / p.ratingCount) : 0,
  }));
  
  leaderboard.sort((a, b) => {
    // Sort primarily by average rating
    if (b.averageRating !== a.averageRating) {
      return b.averageRating - a.averageRating;
    }
    // As a tie-breaker, sort by number of ratings
    return b.ratingCount - a.ratingCount;
  });

  return { leaderboard: leaderboard };
}


/**
 * Finds all unique venues with performances scheduled for today.
 */
function handleGetVenuesForToday() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PERFORMERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${PERFORMERS_SHEET_NAME}" not found.`);

  const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 4).getValues();
  
  const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');
  
  const venues = new Set();
  data.forEach((row, index) => {
    const venueName = row[2];
    const performanceDateValue = row[3];
    const performanceDateString = normalizeDateString(performanceDateValue, spreadsheetTimezone);

    if (venueName && performanceDateString && performanceDateString === todayString) {
      venues.add(venueName);
    }
  });

  return { venues: Array.from(venues) };
}


/**
 * Gets all performers for a specific venue for today.
 */
function handleGetPerformers(payload) {
    if (!payload.venueName) throw new Error("venueName is required.");

    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PERFORMERS_SHEET_NAME);
    if (!sheet) throw new Error(`Sheet "${PERFORMERS_SHEET_NAME}" not found.`);

    if (sheet.getLastRow() < 2) {
      return { performers: [] };
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
    const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');

    const performers = data.filter(row => {
        const venueName = row[2];
        const performanceDateValue = row[3];
        if (!venueName || venueName.trim().toLowerCase() !== payload.venueName.trim().toLowerCase()) {
            return false;
        }
        const performanceDateString = normalizeDateString(performanceDateValue, spreadsheetTimezone);
        return performanceDateString === todayString;
    }).map(row => ({
        id: row[0],
        name: row[1],
        bio: row[4] || '',
        socialLink: row[5] || '',
        setTime: row[6] || ''
    }));
    
    return { performers };
}


/**
 * Generates a login token and emails a magic link to the user.
 */
function handleRequestLogin(payload) {
  const { email, firstName, lastName, venueName } = payload;
  if (!email || !firstName || !lastName || !venueName) {
    throw new Error("Missing required fields for login request.");
  }

  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RATERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${RATERS_SHEET_NAME}" not found.`);

  const token = Utilities.getUuid();
  const expiry = new Date(new Date().getTime() + TOKEN_EXPIRATION_MINUTES * 60 * 1000);
  
  const data = sheet.getDataRange().getValues();
  let raterRow = -1;
  for (let i = 1; i < data.length; i++) {
    if (data[i][0] === email) {
      raterRow = i + 1;
      break;
    }
  }

  if (raterRow !== -1) {
    sheet.getRange(raterRow, 1, 1, 6).setValues([[email, firstName, lastName, venueName, token, expiry]]);
  } else {
    sheet.appendRow([email, firstName, lastName, venueName, token, expiry]);
  }
  
  const loginUrl = `${WEB_APP_URL}?token=${token}`;
  
  const today = new Date();
  const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
  const formattedDate = Utilities.formatDate(today, spreadsheetTimezone, 'dd MMM');
  
  const subject = `[${formattedDate}] ${firstName}, Your Secure Login Link To Rate Performers At ${venueName}`;
  
  const body = `
    <html>
      <body>
        <h2>Hello ${firstName},</h2>
        <p>Click the link below to securely log in and start rating performers at ${venueName}.</p>
        <p><a href="${loginUrl}" style="font-size: 16px; font-weight: bold; color: white; background-color: #6d28d9; padding: 12px 24px; text-decoration: none; border-radius: 25px;">Log In Now</a></p>
        <p>This link is valid for ${TOKEN_EXPIRATION_MINUTES} minutes and can only be used once.</p>
        <p>If you did not request this link, you can safely ignore this email.</p>
      </body>
    </html>`;
  
  MailApp.sendEmail({
    to: email,
    from: 'team@ukmusiciansnetwork.com',
    subject: subject,
    htmlBody: body,
  });

  return { message: 'Login link sent.' };
}


/**
 * Verifies a login token and returns user details.
 */
function handleVerifyToken(payload) {
  const { token } = payload;
  if (!token) throw new Error("Token is required for verification.");

  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RATERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${RATERS_SHEET_NAME}" not found.`);

  const data = sheet.getDataRange().getValues();
  
  let raterInfo = null;
  for (let i = 1; i < data.length; i++) {
    if (data[i][4] === token) { // Column E is Auth Token
      const expiryDate = new Date(data[i][5]); // Column F is Token Expiry
      if (expiryDate.getTime() > new Date().getTime()) {
        raterInfo = {
          email: data[i][0],
          firstName: data[i][1],
          lastName: data[i][2],
          venue: data[i][3],
        };
        sheet.getRange(i + 1, 5, 1, 2).setValues([["", ""]]);
      }
      break;
    }
  }

  if (raterInfo) {
    return raterInfo;
  } else {
    throw new Error("Invalid or expired token.");
  }
}

/**
 * Retrieves all ratings submitted by a specific rater for a specific venue today.
 */
function handleGetTodaysRatings(payload) {
    const { raterEmail, venueName } = payload;
    if (!raterEmail || !venueName) throw new Error("raterEmail and venueName are required.");

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(RATINGS_SHEET_NAME);
    
    if (!sheet || sheet.getLastRow() < 2) {
      return { ratings: {} };
    }

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues();
    const spreadsheetTimezone = ss.getSpreadsheetTimeZone();
    const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');
    
    const ratings = {};
    data.forEach(row => {
        const timestampString = normalizeDateString(row[0], spreadsheetTimezone);
        const currentRaterEmail = row[1];
        const currentVenueName = row[4];
        
        if (timestampString === todayString && currentRaterEmail === raterEmail && currentVenueName && currentVenueName.trim().toLowerCase() === venueName.trim().toLowerCase()) {
            const performerId = row[5];
            const ratingValue = row[7];
            ratings[performerId] = ratingValue;
        }
    });

    return { ratings };
}


/**
 * Submits new ratings to the spreadsheet.
 */
function handleSubmitRatings(payload) {
  const { ratings, raterEmail, firstName, lastName, venueName, latitude, longitude } = payload;
  if (!ratings || !raterEmail || !venueName || !firstName || !lastName) {
    throw new Error("Missing required fields for submitting ratings.");
  }
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
  if (!ratingsSheet) throw new Error(`Sheet "${RATINGS_SHEET_NAME}" not found.`);

  const performersSheet = ss.getSheetByName(PERFORMERS_SHEET_NAME);
  const performerData = performersSheet.getRange(2, 1, performersSheet.getLastRow() - 1, 2).getValues();
  const performerNameMap = performerData.reduce((map, row) => {
    map[row[0]] = row[1];
    return map;
  }, {});

  const timestamp = new Date();
  
  const rowsToAdd = ratings.map(rating => {
    const performerName = performerNameMap[rating.id] || 'Performer Not Found';
    return [
      timestamp,
      raterEmail,
      firstName,
      lastName,
      venueName,
      rating.id,
      performerName,
      rating.rating,
      (rating.feedbackTags || []).join(', '),
      latitude || '',
      longitude || '',
      rating.comment || ''
    ];
  });
  
  if (rowsToAdd.length > 0) {
      ratingsSheet.getRange(ratingsSheet.getLastRow() + 1, 1, rowsToAdd.length, rowsToAdd[0].length).setValues(rowsToAdd);
  }

  return { message: 'Ratings submitted successfully.' };
}

/**
 * A diagnostic function to help debug date parsing issues.
 */
function handleDebugDateParsing() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(PERFORMERS_SHEET_NAME);
  if (!sheet) throw new Error(`Sheet "${PERFORMERS_SHEET_NAME}" not found.`);
  
  const spreadsheetTimezone = SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone();
  const todayString = Utilities.formatDate(new Date(), spreadsheetTimezone, 'yyyy-MM-dd');
  
  const numRowsToFetch = Math.min(sheet.getLastRow(), 16);
  if (numRowsToFetch < 2) {
    return { 
        today: todayString,
        timezone: spreadsheetTimezone,
        debugData: [{ row: 0, originalDate: 'Sheet is empty or has no data rows.', normalizedDate: 'N/A'}]
    };
  }

  const data = sheet.getRange(2, 4, numRowsToFetch - 1, 1).getValues();
  
  const debugData = data.map((row, index) => {
    const dateValue = row[0];
    return {
      row: index + 2,
      originalDate: dateValue,
      dateType: typeof dateValue,
      isDateObject: dateValue instanceof Date,
      normalizedDate: normalizeDateString(dateValue, spreadsheetTimezone),
    };
  });
  
  return { 
    today: todayString,
    timezone: spreadsheetTimezone,
    debugData: debugData
  };
}