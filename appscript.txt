// =================================================================
// CONFIGURATION
// =================================================================

// IMPORTANT: This should be the URL of your deployed frontend web app.
// Used for CORS headers to ensure security.
const WEB_APP_URL = 'https://rate.ukmusiciansnetwork.com'; 

// --- Sheet Names (NEW STRUCTURE) ---
const USERS_SHEET_NAME = 'Users';
const VENUES_SHEET_NAME = 'Venues';
const EVENTS_SHEET_NAME = 'Events';
const RATINGS_SHEET_NAME = 'Ratings';
const PERFORMER_STATS_SHEET_NAME = 'PerformerStats';
const RATER_STATS_SHEET_NAME = 'RaterStats';
const DATA_VALIDATION_SHEET_NAME = 'DataValidation';

// --- Token Expiration (in minutes) ---
const TOKEN_EXPIRATION_MINUTES = 15;

// --- Gameplay Mechanics ---
const DAILY_XP_COOLDOWN_PERCENTAGE = 0.05; // 5% daily cooldown

// --- Scout Points (SP) for Raters ---
const SP_PER_RATING = 5;
const SP_FOR_TAGS = 10;
const SP_FOR_SHORT_COMMENT = 5;
const SP_FOR_DETAILED_COMMENT = 20;
const MIN_SHORT_COMMENT_LENGTH = 5;
const MIN_DETAILED_COMMENT_LENGTH = 50;


// --- Gemini API Configuration ---
const API_KEY = PropertiesService.getScriptProperties().getProperty('API_KEY');


// =================================================================
// MAIN ROUTER & ENDPOINTS (doGet, doPost)
// =================================================================

/**
 * Handles GET requests. Acts as a router.
 * - Default: Returns a JSON status for app diagnostics.
 * - With ?action=manifest: Returns an XML manifest of the spreadsheet structure.
 */
function doGet(e) {
  const action = e && e.parameter && e.parameter.action;
  
  // Test function for diagnostics
  if (action === 'test') {
    return testHttpHeader();
  }

  if (action === 'manifest') {
    const targetId = e.parameter.id ? e.parameter.id : SpreadsheetApp.getActive().getId();
    const ss = SpreadsheetApp.openById(targetId);
    const { xml } = buildManifestXML_(ss);
    return ContentService.createTextOutput(xml).setMimeType(ContentService.MimeType.XML);
  }

  // Default behavior for the app's connection test
  return createSuccessResponse({ message: "Deployment is active." });
}

/**
 * Handles POST requests, which is the main entry point for the app.
 */
function doPost(e) {
  try {
    const payload = JSON.parse(e.postData.contents);
    switch(payload.action) {
      case 'getPerformers': return handleGetPerformers(payload.venueName);
      case 'submitRatings': return handleSubmitRatings(payload);
      case 'requestLogin': return handleRequestLogin(payload);
      case 'verifyToken': return handleVerifyToken(payload.token);
      case 'getVenuesForToday': return handleGetVenuesForToday();
      case 'getTodaysRatings': return handleGetTodaysRatings(payload);
      case 'getLeaderboardData': return handleGetLeaderboardData(payload.venueName, 'today');
      case 'getAllTimeLeaderboardData': return handleGetLeaderboardData(payload.venueName, 'all_time');
      case 'getFeedbackTags': return handleGetFeedbackTags();
      case 'getTodaysFeedbackSummary': return handleGetFeedbackSummary(payload, 'today');
      case 'getAllTimeFeedbackSummary': return handleGetFeedbackSummary(payload, 'all_time');
      case 'getRaterStats': return handleGetRaterStats(payload.raterEmail);
      case 'getScoutLevels': return handleGetScoutLevels();
      case 'registerPerformer': return handleRegisterPerformer(payload);
      case 'loginOrCreateRater': return handleLoginOrCreateRater(payload);
      case 'debugDateParsing': return handleDebugDateParsing();
      default: return createErrorResponse(`Unknown action: ${payload.action}`, 400);
    }
  } catch (err) {
    Logger.log(`doPost Error: ${err.message}\nStack: ${err.stack}`);
    return createErrorResponse(`Server Error: ${err.message}`, 500);
  }
}

// =================================================================
// CUSTOM MENU & MANIFEST FUNCTIONS (from Menu Functions.gs)
// =================================================================

/**
 * Adds a custom 'Manifest' menu to the Google Sheet UI when it's opened.
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Manifest')
    .addItem('Generate XML Manifest (save to Drive)', 'generateSheetManifestXML')
    .addItem('Preview XML in Log', 'previewSheetManifestXML')
    .addToUi();
}

/**
 * Generates the XML manifest and saves it as a file in Google Drive.
 */
function generateSheetManifestXML() {
  const { xml, filename } = buildManifestXML_(SpreadsheetApp.getActive());
  const blob = Utilities.newBlob(xml, 'application/xml', filename);
  const file = DriveApp.createFile(blob);
  SpreadsheetApp.getActive().toast('XML manifest created: ' + file.getUrl(), 'Done', 10);
  Logger.log('Manifest URL: %s', file.getUrl());
}

/**
 * Generates the XML manifest and logs it to the Apps Script logger for previewing.
 */
function previewSheetManifestXML() {
  const { xml } = buildManifestXML_(SpreadsheetApp.getActive());
  Logger.log(xml);
}

/**
 * Core logic to build the XML manifest string from a spreadsheet object.
 * @param {Spreadsheet} ss The spreadsheet to manifest.
 * @returns {{xml: string, filename: string}} The generated XML and a suggested filename.
 */
function buildManifestXML_(ss) {
  const esc = (s) => String(s ?? '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');

  const sheets = ss.getSheets();
  const parts = [];
  parts.push('<?xml version="1.0" encoding="UTF-8"?>');
  parts.push(`<spreadsheet name="${esc(ss.getName())}" id="${esc(ss.getId())}">`);

  sheets.forEach((sh, idx) => {
    const lastCol = sh.getLastColumn();
    const headers = lastCol > 0
      ? sh.getRange(1, 1, 1, lastCol).getDisplayValues()[0]
      : [];
    const headerXml = headers
      .map(h => `      <h>${esc(h)}</h>`)
      .join('\n');

    parts.push(
      `  <sheet name="${esc(sh.getName())}" index="${idx}" gid="${sh.getSheetId()}">`,
      '    <headers>',
      headerXml || '      <!-- (no headers found) -->',
      '    </headers>',
      '  </sheet>'
    );
  });

  parts.push('</spreadsheet>');

  const xml = parts.join('\n');
  const filename = `${ss.getName()}_manifest.xml`;
  return { xml, filename };
}


// =================================================================
// TIME-DRIVEN TRIGGERS
// =================================================================

/**
 * Snapshots key stats for all performers. Should be run daily.
 */
function snapshotDailyStats() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
  if (!statsSheet || statsSheet.getLastRow() < 2) {
    Logger.log("snapshotDailyStats: PerformerStats sheet not found or empty. Skipping.");
    return;
  }

  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const range = statsSheet.getRange(2, 1, statsSheet.getLastRow() - 1, statsSheet.getLastColumn());
    const values = range.getValues();
    
    const headers = statsSheet.getRange(1, 1, 1, statsSheet.getLastColumn()).getValues()[0];
    const headerMap = getHeaderMap(headers);
    
    const currentXPIndex = headerMap['currentxp'];
    const prevDayXPIndex = headerMap['previousdayxp'];
    const totalRatingsIndex = headerMap['totalratingsreceived'];
    const prevTotalRatingsIndex = headerMap['previoustotalratings'];
    const sumRatingsIndex = headerMap['sumofallratings'];
    const prevSumRatingsIndex = headerMap['previoussumofallratings'];

    if ([currentXPIndex, prevDayXPIndex, totalRatingsIndex, prevTotalRatingsIndex, sumRatingsIndex, prevSumRatingsIndex].includes(undefined)) {
      throw new Error("snapshotDailyStats: Could not find all required headers in PerformerStats.");
    }

    const newValues = values.map(row => {
      const currentXP = Number(row[currentXPIndex]) || 0;
      
      // Apply cooldown to current XP
      row[currentXPIndex] = Math.floor(currentXP * (1 - DAILY_XP_COOLDOWN_PERCENTAGE));
      
      // Snapshot pre-cooldown stats
      row[prevDayXPIndex] = currentXP;
      row[prevTotalRatingsIndex] = row[totalRatingsIndex];
      row[prevSumRatingsIndex] = row[sumRatingsIndex];
      
      return row;
    });

    range.setValues(newValues);
    Logger.log(`snapshotDailyStats: Successfully updated stats for ${newValues.length} performers.`);

  } catch (e) {
    Logger.log(`snapshotDailyStats: An error occurred: ${e.message}`);
  } finally {
    lock.releaseLock();
  }
}

/**
 * Snapshots weekly XP for all performers. Should be run weekly.
 */
function snapshotWeeklyXP() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
  if (!statsSheet || statsSheet.getLastRow() < 2) return;

  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const range = statsSheet.getRange(2, 1, statsSheet.getLastRow() - 1, statsSheet.getLastColumn());
    const values = range.getValues();
    
    const headers = statsSheet.getRange(1, 1, 1, statsSheet.getLastColumn()).getValues()[0];
    const headerMap = getHeaderMap(headers);
    const currentXPIndex = headerMap['currentxp'];
    const prevWeekXPIndex = headerMap['previousweekxp'];
    
    if (currentXPIndex === undefined || prevWeekXPIndex === undefined) {
      throw new Error("snapshotWeeklyXP: Could not find 'CurrentXP' or 'PreviousWeekXP' headers.");
    }

    values.forEach(row => {
      row[prevWeekXPIndex] = row[currentXPIndex];
    });

    range.setValues(values);
    Logger.log(`snapshotWeeklyXP: Successfully updated weekly XP for ${values.length} performers.`);

  } catch (e) {
    Logger.log(`snapshotWeeklyXP: An error occurred: ${e.message}`);
  } finally {
    lock.releaseLock();
  }
}


// =================================================================
// UTILITY & RESPONSE FUNCTIONS
// =================================================================

function getHeaderMap(headers) {
  if (!headers || !Array.isArray(headers)) return {};
  return headers.reduce((map, header, index) => {
    if (typeof header === 'string' && header.trim() !== '') {
      map[header.toLowerCase().replace(/[^a-z0-9]/g, '')] = index;
    }
    return map;
  }, {});
}

function getValueByHeader(row, headerMap, targetHeader) {
  const normalizedTarget = targetHeader.toLowerCase().replace(/[^a-z0-9]/g, '');
  const index = headerMap[normalizedTarget];
  return index !== undefined ? row[index] : undefined;
}

function getSpreadsheetTimeZone() {
    return SpreadsheetApp.getActiveSpreadsheet().getSpreadsheetTimeZone() || "Europe/London";
}

function getFormattedDateTime(date) {
    return Utilities.formatDate(date, getSpreadsheetTimeZone(), 'yyyy-MM-dd HH:mm:ss');
}

function getTodaysDateString() {
    return Utilities.formatDate(new Date(), getSpreadsheetTimeZone(), 'yyyy-MM-dd');
}

function normalizeDate(dateValue) {
    const timezone = getSpreadsheetTimeZone();
    try {
        if (dateValue instanceof Date && !isNaN(dateValue)) {
            return Utilities.formatDate(dateValue, timezone, 'yyyy-MM-dd');
        }
        if (typeof dateValue === 'string' && dateValue.trim()) {
            // Handle ISO 8601 format like "2024-07-29T23:00:00.000Z"
            if (dateValue.includes('T') && dateValue.endsWith('Z')) {
                return Utilities.formatDate(new Date(dateValue), timezone, 'yyyy-MM-dd');
            }
            // Handle simple date format like "2024-07-30"
            const parsedDate = new Date(dateValue);
            if (!isNaN(parsedDate)) {
                 return Utilities.formatDate(parsedDate, timezone, 'yyyy-MM-dd');
            }
        }
        if (typeof dateValue === 'number' && dateValue > 0) {
            // Handle Google Sheets serial number dates
            const millis = (dateValue - 25569) * 86400000;
            const dateInUTC = new Date(millis);
            return Utilities.formatDate(dateInUTC, timezone, "yyyy-dd-MM");
        }
    } catch (e) {
        Logger.log(`Could not normalize date value: '${dateValue}' (type: ${typeof dateValue}). Error: ${e.message}`);
    }
    return null;
}

/**
 * Creates a standard success response.
 * Apps Script automatically handles necessary CORS headers for public web apps on simple requests.
 * @param {object} data The data payload to send.
 * @returns {ContentService.TextOutput}
 */
function createSuccessResponse(data) {
  return ContentService
    .createTextOutput(JSON.stringify({ status: 'success', ...data }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Creates a standard error response.
 * @param {string} message The error message.
 * @param {number} [statusCode=500] The HTTP status code (Note: This is informational; Apps Script doesn't allow setting the code here).
 * @returns {ContentService.TextOutput}
 */
function createErrorResponse(message, statusCode = 500) {
  return ContentService
    .createTextOutput(JSON.stringify({ status: 'error', message }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * A minimal test function to diagnose issues with creating responses.
 * @returns {ContentService.TextOutput}
 */
function testHttpHeader() {
  try {
    return ContentService
      .createTextOutput(JSON.stringify({ testStatus: "success" }))
      .setMimeType(ContentService.MimeType.JSON);
  } catch (e) {
    Logger.log('FATAL ERROR in testHttpHeader: ' + e.message);
    return ContentService.createTextOutput('TEST FAILED with error: ' + e.message);
  }
}


// =================================================================
// HANDLER FUNCTIONS
// =================================================================

function handleRegisterPerformer(payload) {
    const lock = LockService.getScriptLock();
    lock.waitLock(30000); 

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
        if (!usersSheet || !statsSheet) throw new Error("Required sheets for registration not found.");

        const headersRaw = usersSheet.getRange(1, 1, 1, usersSheet.getLastColumn()).getValues()[0];
        if (!headersRaw || headersRaw.length === 0) throw new Error("Users sheet is missing headers.");
        const headerMap = getHeaderMap(headersRaw);

        // Check for essential headers to ensure the sheet is structured correctly
        const requiredHeaders = ['userid', 'email', 'firstname', 'lastname', 'performingname', 'registrationdate_performer', 'countrycode'];
        for (const h of requiredHeaders) {
            if (headerMap[h] === undefined) {
                throw new Error(`Critical header "${h}" is missing from the Users sheet.`);
            }
        }

        let imageUrl = '';
        if (payload.imageBase64) {
            const decodedImage = Utilities.base64Decode(payload.imageBase64);
            const blob = Utilities.newBlob(decodedImage, payload.imageMimeType, payload.imageFileName);
            let folder = DriveApp.getFoldersByName('PerformerImages').hasNext() ? DriveApp.getFoldersByName('PerformerImages').next() : DriveApp.createFolder('PerformerImages');
            folder.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
            const file = folder.createFile(blob);
            imageUrl = `https://drive.google.com/uc?export=view&id=${file.getId()}`;
        }
        
        const newUserID = "perf-" + Utilities.getUuid(); // Changed prefix to perf-
        const today = new Date();
        
        // Dynamically build the new row based on the header map
        const newRow = new Array(headersRaw.length).fill(''); // Create an empty array of the correct length
        
        newRow[headerMap['userid']] = newUserID;
        newRow[headerMap['email']] = payload.email;
        newRow[headerMap['firstname']] = payload.firstName;
        newRow[headerMap['lastname']] = payload.lastName;
        newRow[headerMap['countrycode']] = payload.countryCode || '';
        newRow[headerMap['mobilenumber']] = payload.mobile || '';
        newRow[headerMap['creationdate']] = getFormattedDateTime(today);
        newRow[headerMap['performingname']] = payload.performingName;
        newRow[headerMap['bio']] = payload.bio || '';
        newRow[headerMap['sociallink']] = payload.socialLink || '';
        newRow[headerMap['streaminglink']] = payload.streamingLink || '';
        newRow[headerMap['imageurl']] = imageUrl;
        newRow[headerMap['registrationdate_performer']] = getFormattedDateTime(today);
        
        usersSheet.appendRow(newRow);
        
        // Create corresponding entry in PerformerStats
        const statsHeadersRaw = statsSheet.getRange(1, 1, 1, statsSheet.getLastColumn()).getValues()[0];
        const statsHeaderMap = getHeaderMap(statsHeadersRaw);
        const newStatsRow = new Array(statsHeadersRaw.length).fill(0); // Default all to 0
        newStatsRow[statsHeaderMap['userid']] = newUserID;
        newStatsRow[statsHeaderMap['performername']] = payload.performingName;
        newStatsRow[statsHeaderMap['lastupdated']] = getFormattedDateTime(today);

        statsSheet.appendRow(newStatsRow);
        
        return createSuccessResponse({ message: 'Performer registered successfully.' });

    } catch(err) {
        Logger.log(`Registration Error: ${err.message}\nStack: ${err.stack}`);
        return createErrorResponse(err.message);
    } finally {
        lock.releaseLock();
    }
}

function handleLoginOrCreateRater(payload) {
  const { email, firstName, lastName } = payload;
  if (!email || !firstName || !lastName) {
    return createErrorResponse("Missing required fields for rater login/creation.", 400);
  }

  const lock = LockService.getUserLock();
  lock.waitLock(30000);

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    if (!usersSheet) throw new Error("Users sheet not found.");

    const data = usersSheet.getDataRange().getValues();
    const headersRaw = data.shift();
    if (!headersRaw) throw new Error("Users sheet is empty or has no headers.");
    const headers = getHeaderMap(headersRaw);
    
    const emailIndex = headers['email'];
    if (emailIndex === undefined) throw new Error("Email column not found in Users sheet.");

    const userRow = data.find(row => row[emailIndex] === email);

    if (userRow) {
      // User already exists, nothing to do.
      return createSuccessResponse({ message: 'Rater already exists.' });
    } else {
      // User does not exist, create them.
      const userId = "user-" + Utilities.getUuid();
      
      const newRow = new Array(headersRaw.length).fill('');
      newRow[headers['userid']] = userId;
      newRow[headers['email']] = email;
      newRow[headers['firstname']] = firstName;
      newRow[headers['lastname']] = lastName;
      newRow[headers['creationdate']] = getFormattedDateTime(new Date());
      
      usersSheet.appendRow(newRow);
      return createSuccessResponse({ message: 'Rater created successfully.' });
    }
  } catch (err) {
    Logger.log(`handleLoginOrCreateRater Error: ${err.message}\nStack: ${err.stack}`);
    return createErrorResponse(err.message);
  } finally {
    lock.releaseLock();
  }
}


function handleGetPerformers(venueName) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
  const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
  const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);

  if (!venuesSheet || !eventsSheet || !usersSheet) {
    return createErrorResponse("Data model sheets not found (Venues, Events, or Users).");
  }

  // 1. Find VenueID from venueName
  const venuesData = venuesSheet.getDataRange().getValues();
  const venuesHeadersRaw = venuesData.shift();
  if (!venuesHeadersRaw) return createSuccessResponse({ performers: [] }); // Empty venues sheet
  const venuesHeaders = getHeaderMap(venuesHeadersRaw);
  const venueRow = venuesData.find(row => getValueByHeader(row, venuesHeaders, 'VenueName') === venueName);
  if (!venueRow) return createSuccessResponse({ performers: [] });
  const venueId = getValueByHeader(venueRow, venuesHeaders, 'VenueID');

  // 2. Find today's events for that VenueID
  const todaysDate = getTodaysDateString();
  const eventsData = eventsSheet.getDataRange().getValues();
  const eventsHeadersRaw = eventsData.shift();
  if (!eventsHeadersRaw) return createSuccessResponse({ performers: [] }); // Empty events sheet
  const eventsHeaders = getHeaderMap(eventsHeadersRaw);
  
  const todaysEvents = eventsData.filter(row => {
    return normalizeDate(getValueByHeader(row, eventsHeaders, 'EventDate')) === todaysDate &&
           getValueByHeader(row, eventsHeaders, 'VenueID') === venueId;
  });
  
  // 3. Get performer details from Users sheet
  const usersData = usersSheet.getDataRange().getValues();
  const usersHeadersRaw = usersData.shift();
  if (!usersHeadersRaw) return createSuccessResponse({ performers: [] }); // Empty users sheet
  const usersHeaders = getHeaderMap(usersHeadersRaw);
  const usersMap = new Map(usersData.map(row => [getValueByHeader(row, usersHeaders, 'UserID'), row]));
  
  // 4. Combine data
  const performers = todaysEvents.map(eventRow => {
    const userId = getValueByHeader(eventRow, eventsHeaders, 'UserID');
    const userRow = usersMap.get(userId);
    if (!userRow) return null;
    
    return {
      id: userId,
      name: getValueByHeader(userRow, usersHeaders, 'PerformingName'),
      bio: getValueByHeader(userRow, usersHeaders, 'Bio'),
      socialLink: getValueByHeader(userRow, usersHeaders, 'SocialLink'),
      streamingLink: getValueByHeader(userRow, usersHeaders, 'StreamingLink'),
      slot: Number(getValueByHeader(eventRow, eventsHeaders, 'SlotNumber')) || undefined,
      image: getValueByHeader(userRow, usersHeaders, 'ImageURL')
    };
  }).filter(Boolean); // Filter out any nulls if a user wasn't found
  
  return createSuccessResponse({ performers });
}

function handleRequestLogin(payload) {
  const { email, venueName, firstName, lastName } = payload;
  if (!email || !venueName || !firstName || !lastName) {
    return createErrorResponse("Missing required fields.", 400);
  }

  const lock = LockService.getUserLock();
  lock.waitLock(30000);

  try {
    const usersSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(USERS_SHEET_NAME);
    const data = usersSheet.getDataRange().getValues();
    const headersRaw = data.shift();
    if (!headersRaw) throw new Error("Users sheet is empty or has no headers.");
    const headers = getHeaderMap(headersRaw);
    
    const emailIndex = headers['email'];
    const userRow = data.find(row => row[emailIndex] === email);
    let userId;

    if (userRow) {
      userId = getValueByHeader(userRow, headers, 'UserID');
    } else {
      userId = "user-" + Utilities.getUuid();
      usersSheet.appendRow([userId, email, firstName, lastName, '', '', getFormattedDateTime(new Date())]);
    }
    
    const token = "T" + Utilities.getUuid().replace(/-/g, "");
    const expiry = new Date().getTime() + TOKEN_EXPIRATION_MINUTES * 60 * 1000;
    PropertiesService.getScriptProperties().setProperty(token, JSON.stringify({ userId, email, venueName, firstName, lastName, expiry }));

    const loginUrl = `${WEB_APP_URL}?token=${token}`;
    MailApp.sendEmail({
      to: email,
      subject: `Your Secure Login Link for ${venueName}`,
      htmlBody: `Hello ${firstName},<br><br>Click the link below to securely log in to rate performers at ${venueName}.<br><br><a href="${loginUrl}" style="padding: 10px 20px; background-color: #6d28d9; color: white; text-decoration: none; border-radius: 5px;">Log In Now</a><br><br>This link expires in ${TOKEN_EXPIRATION_MINUTES} minutes.`,
      name: "UKMN Rating App"
    });

    return createSuccessResponse({ message: 'Login link sent.' });

  } finally {
    lock.releaseLock();
  }
}

function handleVerifyToken(token) {
  if (!token) return createErrorResponse("No token provided.", 400);

  const scriptProperties = PropertiesService.getScriptProperties();
  const tokenDataString = scriptProperties.getProperty(token);
  if (!tokenDataString) return createErrorResponse("Invalid or expired login link.", 401);

  scriptProperties.deleteProperty(token); 
  const tokenData = JSON.parse(tokenDataString);

  if (new Date().getTime() > tokenData.expiry) {
    return createErrorResponse("Login link has expired.", 401);
  }
  
  return createSuccessResponse({
    email: tokenData.email,
    venue: tokenData.venueName,
    firstName: tokenData.firstName,
    lastName: tokenData.lastName
  });
}

function handleGetVenuesForToday() {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
    const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
    if (!eventsSheet || !venuesSheet) throw new Error("Missing Events or Venues sheet.");

    // 1. Cache all venues
    const venuesData = venuesSheet.getDataRange().getValues();
    const venuesHeaderRaw = venuesData.shift(); // remove headers
    if (!venuesHeaderRaw) return createSuccessResponse({ venues: [] });
    const venuesHeaders = getHeaderMap(venuesHeaderRaw);
    if (venuesData.length === 0) return createSuccessResponse({ venues: [] });
    const venuesMap = new Map(venuesData.map(row => [getValueByHeader(row, venuesHeaders, 'venueid'), getValueByHeader(row, venuesHeaders, 'venuename')]));

    // 2. Find today's events
    const todaysDate = getTodaysDateString();
    const eventsData = eventsSheet.getDataRange().getValues();
    const eventsHeadersRaw = eventsData.shift();
    if (!eventsHeadersRaw) return createSuccessResponse({ venues: [] });
    const eventsHeaders = getHeaderMap(eventsHeadersRaw);
    
    const todaysVenueIds = new Set();
    eventsData.forEach(row => {
        if (normalizeDate(getValueByHeader(row, eventsHeaders, 'EventDate')) === todaysDate) {
            todaysVenueIds.add(getValueByHeader(row, eventsHeaders, 'VenueID'));
        }
    });

    // 3. Map IDs to Names
    const venues = Array.from(todaysVenueIds).map(id => venuesMap.get(id)).filter(Boolean);
    
    return createSuccessResponse({ venues });
}

function handleSubmitRatings(payload) {
    const { ratings, raterEmail, venueName, firstName, lastName, latitude, longitude } = payload;
    if (!ratings || !raterEmail || !venueName) {
        return createErrorResponse("Missing required rating data.", 400);
    }
    
    const lock = LockService.getScriptLock();
    lock.waitLock(30000);

    try {
        const ss = SpreadsheetApp.getActiveSpreadsheet();
        const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
        const usersData = usersSheet.getDataRange().getValues();
        const usersHeadersRaw = usersData.shift();
        if (!usersHeadersRaw) throw new Error("Users sheet is empty or missing headers.");
        const usersHeaders = getHeaderMap(usersHeadersRaw);
        const raterRow = usersData.find(row => getValueByHeader(row, usersHeaders, 'email') === raterEmail);
        if (!raterRow) throw new Error("Rater not found.");
        const raterId = getValueByHeader(raterRow, usersHeaders, 'userid');

        const timestamp = new Date();
        let totalPointsEarned = 0;
        
        const ratingsToAdd = ratings.map(rating => {
            let points = 0;
            if (rating.rating > 0) points += SP_PER_RATING;
            if (rating.feedbackTags?.length) points += SP_FOR_TAGS;
            if (rating.comment?.length >= MIN_DETAILED_COMMENT_LENGTH) {
                points += SP_FOR_DETAILED_COMMENT;
            } else if (rating.comment?.length >= MIN_SHORT_COMMENT_LENGTH) {
                points += SP_FOR_SHORT_COMMENT;
            }
            totalPointsEarned += points;

            return [
                "rating-" + Utilities.getUuid(), getFormattedDateTime(timestamp), raterId, rating.id, rating.rating,
                rating.comment || '', (rating.feedbackTags || []).join(', '),
                venueName, latitude, longitude
            ];
        });

        if (ratingsToAdd.length > 0) {
            const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
            ratingsSheet.getRange(ratingsSheet.getLastRow() + 1, 1, ratingsToAdd.length, ratingsToAdd[0].length).setValues(ratingsToAdd);
        }

        // --- Update RaterStats ---
        const raterStatsSheet = ss.getSheetByName(RATER_STATS_SHEET_NAME);
        const raterStatsData = raterStatsSheet.getDataRange().getValues();
        const raterStatsHeadersRaw = raterStatsData.shift();
        if (!raterStatsHeadersRaw) throw new Error("RaterStats sheet is empty or missing headers.");
        const raterStatsHeaders = getHeaderMap(raterStatsHeadersRaw);
        const raterStatsRowIndex = raterStatsData.findIndex(row => getValueByHeader(row, raterStatsHeaders, 'userid') === raterId);
        
        const commentsInSubmission = ratings.filter(r => r.comment?.trim()).length;
        if (raterStatsRowIndex > -1) {
            const rowIndex = raterStatsRowIndex + 2;
            const row = raterStatsData[raterStatsRowIndex];
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['totalsp'] + 1).setValue((Number(getValueByHeader(row, raterStatsHeaders, 'totalsp')) || 0) + totalPointsEarned);
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['ratingssubmitted'] + 1).setValue((Number(getValueByHeader(row, raterStatsHeaders, 'ratingssubmitted')) || 0) + ratings.length);
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['commentswritten'] + 1).setValue((Number(getValueByHeader(row, raterStatsHeaders, 'commentswritten')) || 0) + commentsInSubmission);
            raterStatsSheet.getRange(rowIndex, raterStatsHeaders['lastupdated'] + 1).setValue(getFormattedDateTime(timestamp));
        } else {
            raterStatsSheet.appendRow([raterId, raterEmail, totalPointsEarned, ratings.length, commentsInSubmission, getFormattedDateTime(timestamp)]);
        }

        // --- Batch update PerformerStats ---
        const performerStatsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
        const allStatsData = performerStatsSheet.getDataRange().getValues();
        const statsHeadersRaw = allStatsData.shift();
        if (!statsHeadersRaw) throw new Error("PerformerStats sheet is empty or missing headers.");
        const statsHeaders = getHeaderMap(statsHeadersRaw);
        const statsMap = new Map(allStatsData.map(row => [getValueByHeader(row, statsHeaders, 'userid'), row]));
        
        const allRatingsData = ss.getSheetByName(RATINGS_SHEET_NAME).getDataRange().getValues();
        const ratingsHeadersRaw = allRatingsData.shift();
        if (!ratingsHeadersRaw) throw new Error("Ratings sheet is empty or missing headers.");
        const ratingsHeaders = getHeaderMap(ratingsHeadersRaw);

        const performersToUpdate = new Set(ratings.map(r => r.id));
        performersToUpdate.forEach(performerId => {
            const performerRatings = allRatingsData.filter(r => getValueByHeader(r, ratingsHeaders, 'performeruserid') === performerId);
            const totalRatings = performerRatings.length;
            const sumOfRatings = performerRatings.reduce((sum, r) => sum + (Number(getValueByHeader(r, ratingsHeaders, 'score')) || 0), 0);
            const uniqueRaters = new Set(performerRatings.map(r => getValueByHeader(r, ratingsHeaders, 'rateruserid'))).size;
            const commentsCount = performerRatings.filter(r => getValueByHeader(r, ratingsHeaders, 'comment')?.trim()).length;

            const xp = (totalRatings * SP_PER_RATING) + (commentsCount * SP_FOR_SHORT_COMMENT);
            
            const statsRow = statsMap.get(performerId);
            if (statsRow) {
                statsRow[statsHeaders['totalratingsreceived']] = totalRatings;
                statsRow[statsHeaders['sumofallratings']] = sumOfRatings;
                statsRow[statsHeaders['uniqueratercount']] = uniqueRaters;
                statsRow[statsHeaders['currentxp']] = xp;
                statsRow[statsHeaders['lastupdated']] = getFormattedDateTime(timestamp);
                statsMap.set(performerId, statsRow);
            }
        });

        const updatedStatsValues = Array.from(statsMap.values());
        if (updatedStatsValues.length > 0) {
            performerStatsSheet.getRange(2, 1, updatedStatsValues.length, updatedStatsValues[0].length).setValues(updatedStatsValues);
        }

        return createSuccessResponse({ pointsEarned: totalPointsEarned });

    } catch (err) {
        Logger.log(`handleSubmitRatings Error: ${err.message}\nStack: ${err.stack}`);
        return createErrorResponse(`Submission failed: ${err.message}`);
    } finally {
        lock.releaseLock();
    }
}


function handleGetTodaysRatings(payload) {
    const { raterEmail, venueName } = payload;
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
    const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
    
    const usersData = usersSheet.getDataRange().getValues();
    const usersHeadersRaw = usersData.shift();
    if (!usersHeadersRaw) return createSuccessResponse({ ratings: {} });
    const usersHeaders = getHeaderMap(usersHeadersRaw);
    const raterRow = usersData.find(row => getValueByHeader(row, usersHeaders, 'email') === raterEmail);
    if (!raterRow) return createSuccessResponse({ ratings: {} });
    const raterId = getValueByHeader(raterRow, usersHeaders, 'userid');

    const todaysDate = getTodaysDateString();
    const allRatings = ratingsSheet.getDataRange().getValues();
    const ratingsHeadersRaw = allRatings.shift();
    if (!ratingsHeadersRaw) return createSuccessResponse({ ratings: {} });
    const ratingsHeaders = getHeaderMap(ratingsHeadersRaw);

    const ratingsMap = {};
    allRatings.forEach(row => {
        if (getValueByHeader(row, ratingsHeaders, 'rateruserid') === raterId &&
            getValueByHeader(row, ratingsHeaders, 'venuename') === venueName &&
            normalizeDate(getValueByHeader(row, ratingsHeaders, 'timestamp')) === todaysDate) {
            ratingsMap[getValueByHeader(row, ratingsHeaders, 'performeruserid')] = getValueByHeader(row, ratingsHeaders, 'score');
        }
    });

    return createSuccessResponse({ ratings: ratingsMap });
}

function handleGetLeaderboardData(venueName, timeFrame) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const statsSheet = ss.getSheetByName(PERFORMER_STATS_SHEET_NAME);
    if (!statsSheet) return createErrorResponse("Stats sheet not found.");
    
    const statsData = statsSheet.getDataRange().getValues();
    const statsHeadersRaw = statsData.shift();
    if (!statsHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const statsHeaders = getHeaderMap(statsHeadersRaw);

    if (timeFrame === 'all_time') {
        const leaderboard = statsData.map(row => {
            const totalRatings = Number(getValueByHeader(row, statsHeaders, 'totalratingsreceived')) || 0;
            if (totalRatings === 0) return null;
            const sumRatings = Number(getValueByHeader(row, statsHeaders, 'sumofallratings')) || 0;
            
            const prevTotalRatings = Number(getValueByHeader(row, statsHeaders, 'previoustotalratings')) || 0;
            const prevSumRatings = Number(getValueByHeader(row, statsHeaders, 'previoussumofallratings')) || 0;
            const prevAvg = prevTotalRatings > 0 ? prevSumRatings / prevTotalRatings : 0;
            const currentAvg = sumRatings / totalRatings;

            let ratingTrend = 'STABLE';
            if (currentAvg > prevAvg) ratingTrend = 'UP';
            if (currentAvg < prevAvg) ratingTrend = 'DOWN';

            const currentXP = Number(getValueByHeader(row, statsHeaders, 'currentxp')) || 0;
            const prevWeekXP = Number(getValueByHeader(row, statsHeaders, 'previousweekxp')) || 0;
            let xpTrend = 'STABLE';
            if (currentXP > prevWeekXP) xpTrend = 'UP';
            if (currentXP < prevWeekXP) xpTrend = 'DOWN';
            
            return {
                id: getValueByHeader(row, statsHeaders, 'userid'),
                name: getValueByHeader(row, statsHeaders, 'performername'),
                averageRating: currentAvg,
                ratingCount: totalRatings,
                commentCount: 0, // Note: Comment count not in new stats sheet, default to 0
                xp: currentXP,
                xpTrend: xpTrend,
                ratingTrend: ratingTrend
            };
        }).filter(Boolean);

        leaderboard.sort((a, b) => b.averageRating - a.averageRating || b.ratingCount - a.ratingCount);
        return createSuccessResponse({ leaderboard });
    }

    // --- Logic for 'today' ---
    const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
    const eventsData = eventsSheet.getDataRange().getValues();
    const eventsHeadersRaw = eventsData.shift();
    if (!eventsHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const eventsHeaders = getHeaderMap(eventsHeadersRaw);

    const venuesSheet = ss.getSheetByName(VENUES_SHEET_NAME);
    const venuesData = venuesSheet.getDataRange().getValues();
    const venuesHeadersRaw = venuesData.shift();
    if (!venuesHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const venuesHeaders = getHeaderMap(venuesHeadersRaw);

    const venueRow = venuesData.find(r => getValueByHeader(r, venuesHeaders, 'venuename') === venueName);
    if (!venueRow) return createSuccessResponse({ leaderboard: [] });
    const venueId = getValueByHeader(venueRow, venuesHeaders, 'venueid');

    const todaysDate = getTodaysDateString();
    const performersToday = new Set(eventsData
        .filter(r => normalizeDate(getValueByHeader(r, eventsHeaders, 'eventdate')) === todaysDate && getValueByHeader(r, eventsHeaders, 'venueid') === venueId)
        .map(r => getValueByHeader(r, eventsHeaders, 'userid'))
    );

    const ratingsSheet = ss.getSheetByName(RATINGS_SHEET_NAME);
    const ratingsData = ratingsSheet.getDataRange().getValues();
    const ratingsHeadersRaw = ratingsData.shift();
    if (!ratingsHeadersRaw) return createSuccessResponse({ leaderboard: [] });
    const ratingsHeaders = getHeaderMap(ratingsHeadersRaw);

    const todaysRatings = {}; // { performerId: { ratings: [], comments: 0 } }
    ratingsData.forEach(row => {
        const performerId = getValueByHeader(row, ratingsHeaders, 'performeruserid');
        if (performersToday.has(performerId) && normalizeDate(getValueByHeader(row, ratingsHeaders, 'timestamp')) === todaysDate) {
            if (!todaysRatings[performerId]) {
                todaysRatings[performerId] = { ratings: [], comments: 0 };
            }
            todaysRatings[performerId].ratings.push(Number(getValueByHeader(row, ratingsHeaders, 'score')) || 0);
            if (getValueByHeader(row, ratingsHeaders, 'comment')?.trim()) {
                todaysRatings[performerId].comments++;
            }
        }
    });

    const statsMap = new Map(statsData.map(row => [getValueByHeader(row, statsHeaders, 'userid'), row]));
    
    const leaderboard = Object.keys(todaysRatings).map(performerId => {
        const statsRow = statsMap.get(performerId);
        if (!statsRow) return null;

        const todaysData = todaysRatings[performerId];
        const todaysSum = todaysData.ratings.reduce((a, b) => a + b, 0);
        const todaysAvg = todaysSum / todaysData.ratings.length;

        const totalRatings = Number(getValueByHeader(statsRow, statsHeaders, 'totalratingsreceived')) || 0;
        const sumRatings = Number(getValueByHeader(statsRow, statsHeaders, 'sumofallratings')) || 0;
        const allTimeAvg = totalRatings > 0 ? sumRatings / totalRatings : 0;
        
        let ratingTrend = 'STABLE';
        if (todaysAvg > allTimeAvg) ratingTrend = 'UP';
        if (todaysAvg < allTimeAvg) ratingTrend = 'DOWN';

        return {
            id: performerId,
            name: getValueByHeader(statsRow, statsHeaders, 'performername'),
            averageRating: todaysAvg,
            ratingCount: todaysData.ratings.length,
            commentCount: todaysData.comments,
            ratingTrend: ratingTrend
        };
    }).filter(Boolean);

    leaderboard.sort((a, b) => b.averageRating - a.averageRating || b.ratingCount - a.ratingCount);
    return createSuccessResponse({ leaderboard });
}

function handleGetFeedbackTags() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(DATA_VALIDATION_SHEET_NAME);
  if (!sheet) return createErrorResponse("DataValidation sheet not found.");
  
  const data = sheet.getDataRange().getValues();
  data.shift(); // remove headers
  
  const positive = data
    .filter(row => row[0] === 'Feedback' && row[1] === 'Positive' && row[2]) // Filter for Category='Feedback', Sub Category='Positive', and non-empty tag
    .map(row => row[2]); // Get the tag from Column C

  const constructive = data
    .filter(row => row[0] === 'Feedback' && row[1] === 'Constructive' && row[2]) // Filter for Category='Feedback', Sub Category='Constructive', and non-empty tag
    .map(row => row[2]); // Get the tag from Column C

  return createSuccessResponse({ positive, constructive });
}

function handleGetRaterStats(raterEmail) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const usersSheet = ss.getSheetByName(USERS_SHEET_NAME);
  const raterStatsSheet = ss.getSheetByName(RATER_STATS_SHEET_NAME);
  
  const usersData = usersSheet.getDataRange().getValues();
  const usersHeadersRaw = usersData.shift();
  if (!usersHeadersRaw) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  const usersHeaders = getHeaderMap(usersHeadersRaw);
  const userRow = usersData.find(row => getValueByHeader(row, usersHeaders, 'email') === raterEmail);
  if (!userRow) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  const userId = getValueByHeader(userRow, usersHeaders, 'userid');
  
  const statsData = raterStatsSheet.getDataRange().getValues();
  const statsHeadersRaw = statsData.shift();
  if (!statsHeadersRaw) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  const statsHeaders = getHeaderMap(statsHeadersRaw);
  const statsRow = statsData.find(row => getValueByHeader(row, statsHeaders, 'userid') === userId);
  if (!statsRow) return createSuccessResponse({ stats: { totalSP: 0, ratingsSubmitted: 0, commentsWritten: 0 }});
  
  return createSuccessResponse({
    stats: {
      totalSP: Number(getValueByHeader(statsRow, statsHeaders, 'totalsp')) || 0,
      ratingsSubmitted: Number(getValueByHeader(statsRow, statsHeaders, 'ratingssubmitted')) || 0,
      commentsWritten: Number(getValueByHeader(statsRow, statsHeaders, 'commentswritten')) || 0,
    }
  });
}

function handleGetScoutLevels() {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(DATA_VALIDATION_SHEET_NAME);
  if (!sheet) return createSuccessResponse({ scoutLevels: [] });
  const data = sheet.getRange("E2:F").getValues();
  const scoutLevels = data.filter(row => row[0] && typeof row[1] === 'number')
                          .map(row => ({ name: row[0], minSP: row[1] }))
                          .sort((a, b) => a.minSP - b.minSP);
  return createSuccessResponse({ scoutLevels });
}

function handleGetFeedbackSummary(payload, timeFrame) {
    if (!API_KEY) return createErrorResponse("API key is not configured.");
    const { performerId, venueName } = payload;
    const ratingsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(RATINGS_SHEET_NAME);
    const allRatings = ratingsSheet.getDataRange().getValues();
    const headersRaw = allRatings.shift();
    if (!headersRaw) return createErrorResponse("Ratings sheet is empty or missing headers.");
    const headers = getHeaderMap(headersRaw);

    const todaysDate = getTodaysDateString();

    const comments = allRatings.filter(row => {
        const rowComment = getValueByHeader(row, headers, 'comment')?.trim();
        if (getValueByHeader(row, headers, 'performeruserid') !== performerId || !rowComment) return false;
        if (timeFrame === 'today') {
            return normalizeDate(getValueByHeader(row, headers, 'timestamp')) === todaysDate &&
                   getValueByHeader(row, headers, 'venuename') === venueName;
        }
        return true;
    }).map(row => `- "${getValueByHeader(row, headers, 'comment').trim()}"`);

    if (comments.length < 2) return createErrorResponse("Not enough comments to generate a summary.");
    
    const prompt = `You are an A&R assistant providing feedback to a musician. Analyze the following anonymous comments and provide a concise, actionable summary. Start with a one-sentence summary, then list up to 3 strengths and 3 areas for improvement as bullet points. Be encouraging and constructive. Do not use markdown headers. Keep it brief. Comments:\n${comments.join('\n')}`;
    
    const response = UrlFetchApp.fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${API_KEY}`, {
        method: 'post',
        contentType: 'application/json',
        payload: JSON.stringify({ "contents": [{ "parts": [{ "text": prompt }] }] }),
        muteHttpExceptions: true
    });
    
    const jsonResponse = JSON.parse(response.getContentText());
    if (response.getResponseCode() !== 200) {
        return createErrorResponse("AI feedback generator failed: " + (jsonResponse.error?.message || "Unknown API error."));
    }
    const summaryText = jsonResponse.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!summaryText) {
        return createErrorResponse("AI feedback generator returned an empty response.");
    }
    return createSuccessResponse({ summary: summaryText });
}

function handleDebugDateParsing() {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(EVENTS_SHEET_NAME);
    if (!sheet) return createErrorResponse("Events sheet not found for diagnostics.");
    if (sheet.getLastRow() < 2) return createSuccessResponse({ today: getTodaysDateString(), timezone: getSpreadsheetTimeZone(), debugData: [] });

    const data = sheet.getRange("B2:B" + sheet.getLastRow()).getValues();
    const debugData = data.map((row, index) => ({
        row: index + 2,
        originalDate: row[0],
        dateType: typeof row[0],
        isDateObject: row[0] instanceof Date,
        normalizedDate: normalizeDate(row[0])
    }));
    return createSuccessResponse({ today: getTodaysDateString(), timezone: getSpreadsheetTimeZone(), debugData });
}